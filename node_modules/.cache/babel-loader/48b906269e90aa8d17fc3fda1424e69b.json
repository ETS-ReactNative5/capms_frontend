{"ast":null,"code":"/*\n Highcharts JS v9.3.1 (2021-11-05)\n\n Variable Pie module for Highcharts\n\n (c) 2010-2021 Grzegorz Blachliski\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (a) {\n  \"object\" === typeof module && module.exports ? (a[\"default\"] = a, module.exports = a) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/variable-pie\", [\"highcharts\"], function (e) {\n    a(e);\n    a.Highcharts = e;\n    return a;\n  }) : a(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (a) {\n  function e(a, b, e, m) {\n    a.hasOwnProperty(b) || (a[b] = m.apply(null, e));\n  }\n\n  a = a ? a._modules : {};\n  e(a, \"Series/VariablePie/VariablePieSeries.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, b) {\n    var e = this && this.__extends || function () {\n      var _a = function a(b, c) {\n        _a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, a) {\n          c.__proto__ = a;\n        } || function (c, a) {\n          for (var h in a) {\n            a.hasOwnProperty(h) && (c[h] = a[h]);\n          }\n        };\n\n        return _a(b, c);\n      };\n\n      return function (b, c) {\n        function r() {\n          this.constructor = b;\n        }\n\n        _a(b, c);\n\n        b.prototype = null === c ? Object.create(c) : (r.prototype = c.prototype, new r());\n      };\n    }(),\n        m = a.seriesTypes.pie,\n        w = b.arrayMax,\n        x = b.arrayMin,\n        z = b.clamp,\n        A = b.extend,\n        B = b.fireEvent,\n        C = b.merge,\n        n = b.pick;\n\n    b = function (a) {\n      function b() {\n        var c = null !== a && a.apply(this, arguments) || this;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        c.radii = void 0;\n        return c;\n      }\n\n      e(b, a);\n\n      b.prototype.calculateExtremes = function () {\n        var c = this.chart,\n            a = this.options;\n        var b = this.zData;\n        var e = Math.min(c.plotWidth, c.plotHeight) - 2 * (a.slicedOffset || 0),\n            t = {};\n        c = this.center || this.getCenter();\n        [\"minPointSize\", \"maxPointSize\"].forEach(function (c) {\n          var b = a[c],\n              h = /%$/.test(b);\n          b = parseInt(b, 10);\n          t[c] = h ? e * b / 100 : 2 * b;\n        });\n        this.minPxSize = c[3] + t.minPointSize;\n        this.maxPxSize = z(c[2], c[3] + t.minPointSize, t.maxPointSize);\n        b.length && (c = n(a.zMin, x(b.filter(this.zValEval))), b = n(a.zMax, w(b.filter(this.zValEval))), this.getRadii(c, b, this.minPxSize, this.maxPxSize));\n      };\n\n      b.prototype.getRadii = function (c, a, b, e) {\n        var h = 0,\n            l = this.zData,\n            r = l.length,\n            k = [],\n            m = \"radius\" !== this.options.sizeBy,\n            n = a - c;\n\n        for (h; h < r; h++) {\n          var g = this.zValEval(l[h]) ? l[h] : c;\n          g <= c ? g = b / 2 : g >= a ? g = e / 2 : (g = 0 < n ? (g - c) / n : .5, m && (g = Math.sqrt(g)), g = Math.ceil(b + g * (e - b)) / 2);\n          k.push(g);\n        }\n\n        this.radii = k;\n      };\n\n      b.prototype.redraw = function () {\n        this.center = null;\n        a.prototype.redraw.apply(this, arguments);\n      };\n\n      b.prototype.translate = function (c) {\n        this.generatePoints();\n        var b = 0,\n            a = this.options,\n            e = a.slicedOffset,\n            m = e + (a.borderWidth || 0),\n            l = a.startAngle || 0,\n            u = Math.PI / 180 * (l - 90),\n            k = Math.PI / 180 * (n(a.endAngle, l + 360) - 90);\n        l = k - u;\n        var y = this.points,\n            w = a.dataLabels.distance;\n        a = a.ignoreHiddenPoint;\n        var g = y.length;\n        this.startAngleRad = u;\n        this.endAngleRad = k;\n        this.calculateExtremes();\n        c || (this.center = c = this.getCenter());\n\n        for (k = 0; k < g; k++) {\n          var f = y[k];\n          var p = this.radii[k];\n          f.labelDistance = n(f.options.dataLabels && f.options.dataLabels.distance, w);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, f.labelDistance);\n          var d = u + b * l;\n          if (!a || f.visible) b += f.percentage / 100;\n          var q = u + b * l;\n          f.shapeType = \"arc\";\n          f.shapeArgs = {\n            x: c[0],\n            y: c[1],\n            r: p,\n            innerR: c[3] / 2,\n            start: Math.round(1E3 * d) / 1E3,\n            end: Math.round(1E3 * q) / 1E3\n          };\n          d = (q + d) / 2;\n          d > 1.5 * Math.PI ? d -= 2 * Math.PI : d < -Math.PI / 2 && (d += 2 * Math.PI);\n          f.slicedTranslation = {\n            translateX: Math.round(Math.cos(d) * e),\n            translateY: Math.round(Math.sin(d) * e)\n          };\n          var v = Math.cos(d) * c[2] / 2;\n          var x = Math.sin(d) * c[2] / 2;\n          q = Math.cos(d) * p;\n          p *= Math.sin(d);\n          f.tooltipPos = [c[0] + .7 * v, c[1] + .7 * x];\n          f.half = d < -Math.PI / 2 || d > Math.PI / 2 ? 1 : 0;\n          f.angle = d;\n          v = Math.min(m, f.labelDistance / 5);\n          f.labelPosition = {\n            natural: {\n              x: c[0] + q + Math.cos(d) * f.labelDistance,\n              y: c[1] + p + Math.sin(d) * f.labelDistance\n            },\n            \"final\": {},\n            alignment: f.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: c[0] + q + Math.cos(d) * v,\n                y: c[1] + p + Math.sin(d) * v\n              },\n              touchingSliceAt: {\n                x: c[0] + q,\n                y: c[1] + p\n              }\n            }\n          };\n        }\n\n        B(this, \"afterTranslate\");\n      };\n\n      b.prototype.zValEval = function (a) {\n        return \"number\" !== typeof a || isNaN(a) ? null : !0;\n      };\n\n      b.defaultOptions = C(m.defaultOptions, {\n        minPointSize: \"10%\",\n        maxPointSize: \"100%\",\n        zMin: void 0,\n        zMax: void 0,\n        sizeBy: \"area\",\n        tooltip: {\n          pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>\"\n        }\n      });\n      return b;\n    }(m);\n\n    A(b.prototype, {\n      pointArrayMap: [\"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"]\n    });\n    a.registerSeriesType(\"variablepie\", b);\n    \"\";\n    \"\";\n    return b;\n  });\n  e(a, \"masters/modules/variable-pie.src.js\", [], function () {});\n});","map":null,"metadata":{},"sourceType":"script"}