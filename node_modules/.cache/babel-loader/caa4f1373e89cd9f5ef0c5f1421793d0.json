{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar log = require('npmlog');\n\nvar existsAsync = fs.exists || path.exists;\n\nvar versioning = require('./util/versioning.js');\n\nvar napi = require('./util/napi.js');\n\nvar makeDir = require('make-dir'); // for fetching binaries\n\n\nvar fetch = require('node-fetch');\n\nvar tar = require('tar');\n\nvar npgVersion = 'unknown';\n\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  var ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {// do nothing\n}\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri); // Try getting version info from the currently running npm.\n\n  var envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  var sanitized = uri.replace('+', '%2B');\n  var requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  var proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n  var agent;\n\n  if (proxyUrl) {\n    var ProxyAgent = require('https-proxy-agent');\n\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n\n  fetch(sanitized, {\n    agent: agent\n  }).then(function (res) {\n    if (!res.ok) {\n      throw new Error(\"response status \".concat(res.status, \" \").concat(res.statusText, \" on \").concat(sanitized));\n    }\n\n    var dataStream = res.body;\n    return new Promise(function (resolve, reject) {\n      var extractions = 0;\n\n      var countExtractions = function countExtractions(entry) {\n        extractions += 1;\n        log.info('install', 'unpacking %s', entry.path);\n      };\n\n      dataStream.pipe(extract(targetDir, countExtractions)).on('error', function (e) {\n        reject(e);\n      });\n      dataStream.on('end', function () {\n        resolve(\"extracted file count: \".concat(extractions));\n      });\n      dataStream.on('error', function (e) {\n        reject(e);\n      });\n    });\n  }).then(function (text) {\n    log.info(text);\n    callback();\n  }).catch(function (e) {\n    log.error(\"install \".concat(e.message));\n    callback(e);\n  });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry: onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n\n  log.info('Found local file to extract from ' + from); // extract helpers\n\n  var extractCount = 0;\n\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n\n  function afterExtract(err) {\n    if (err) return callback(err);\n\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions)).on('close', afterExtract).on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  var args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  var fallback_message = ' (falling back to source compile with node-gyp)';\n  var full_message = '';\n\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n} //\n// install\n//\n\n\nfunction install(gyp, argv, callback) {\n  var package_json = gyp.package_json;\n  var napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  var source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  var update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  var should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    var fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    var should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true'; // but allow override from npm\n\n    if (process.env.npm_config_argv) {\n      var cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      var match = cooked.indexOf('--fallback-to-build');\n\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n\n    var opts;\n\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    var from = opts.hosted_tarball;\n    var to = opts.module_path;\n    var binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, function (found) {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(function () {\n        var fileName = from.startsWith('file://') && from.slice('file://'.length);\n\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch(function (err) {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}