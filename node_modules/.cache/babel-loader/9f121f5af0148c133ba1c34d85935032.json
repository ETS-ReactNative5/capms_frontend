{"ast":null,"code":"'use strict'; // wrapper around mkdirp for tar's needs.\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nvar mkdirp = require('mkdirp');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar chownr = require('chownr');\n\nvar normPath = require('./normalize-windows-path.js');\n\nvar SymlinkError = /*#__PURE__*/function (_Error) {\n  _inherits(SymlinkError, _Error);\n\n  var _super = _createSuper(SymlinkError);\n\n  function SymlinkError(symlink, path) {\n    var _this;\n\n    _classCallCheck(this, SymlinkError);\n\n    _this = _super.call(this, 'Cannot extract through symbolic link');\n    _this.path = path;\n    _this.symlink = symlink;\n    return _this;\n  }\n\n  _createClass(SymlinkError, [{\n    key: \"name\",\n    get: function get() {\n      return 'SylinkError';\n    }\n  }]);\n\n  return SymlinkError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar CwdError = /*#__PURE__*/function (_Error2) {\n  _inherits(CwdError, _Error2);\n\n  var _super2 = _createSuper(CwdError);\n\n  function CwdError(path, code) {\n    var _this2;\n\n    _classCallCheck(this, CwdError);\n\n    _this2 = _super2.call(this, code + ': Cannot cd into \\'' + path + '\\'');\n    _this2.path = path;\n    _this2.code = code;\n    return _this2;\n  }\n\n  _createClass(CwdError, [{\n    key: \"name\",\n    get: function get() {\n      return 'CwdError';\n    }\n  }]);\n\n  return CwdError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar cGet = function cGet(cache, key) {\n  return cache.get(normPath(key));\n};\n\nvar cSet = function cSet(cache, key, val) {\n  return cache.set(normPath(key), val);\n};\n\nvar checkCwd = function checkCwd(dir, cb) {\n  fs.stat(dir, function (er, st) {\n    if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || 'ENOTDIR');\n    cb(er);\n  });\n};\n\nmodule.exports = function (dir, opt, cb) {\n  dir = normPath(dir); // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = normPath(opt.cwd);\n\n  var done = function done(er, created) {\n    if (er) cb(er);else {\n      cSet(cache, dir, true);\n      if (created && doChown) chownr(created, uid, gid, function (er) {\n        return done(er);\n      });else if (needChmod) fs.chmod(dir, mode, cb);else cb();\n    }\n  };\n\n  if (cache && cGet(cache, dir) === true) return done();\n  if (dir === cwd) return checkCwd(dir, done);\n  if (preserve) return mkdirp(dir, {\n    mode: mode\n  }).then(function (made) {\n    return done(null, made);\n  }, done);\n  var sub = normPath(path.relative(cwd, dir));\n  var parts = sub.split('/');\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\n\nvar mkdir_ = function mkdir_(base, parts, mode, cache, unlink, cwd, created, cb) {\n  if (!parts.length) return cb(null, created);\n  var p = parts.shift();\n  var part = normPath(path.resolve(base + '/' + p));\n  if (cGet(cache, part)) return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\n\nvar onmkdir = function onmkdir(part, parts, mode, cache, unlink, cwd, created, cb) {\n  return function (er) {\n    if (er) {\n      fs.lstat(part, function (statEr, st) {\n        if (statEr) {\n          statEr.path = statEr.path && normPath(statEr.path);\n          cb(statEr);\n        } else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);else if (unlink) {\n          fs.unlink(part, function (er) {\n            if (er) return cb(er);\n            fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n          });\n        } else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + '/' + parts.join('/')));else cb(er);\n      });\n    } else {\n      created = created || part;\n      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n  };\n};\n\nvar checkCwdSync = function checkCwdSync(dir) {\n  var ok = false;\n  var code = 'ENOTDIR';\n\n  try {\n    ok = fs.statSync(dir).isDirectory();\n  } catch (er) {\n    code = er.code;\n  } finally {\n    if (!ok) throw new CwdError(dir, code);\n  }\n};\n\nmodule.exports.sync = function (dir, opt) {\n  dir = normPath(dir); // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = normPath(opt.cwd);\n\n  var done = function done(created) {\n    cSet(cache, dir, true);\n    if (created && doChown) chownr.sync(created, uid, gid);\n    if (needChmod) fs.chmodSync(dir, mode);\n  };\n\n  if (cache && cGet(cache, dir) === true) return done();\n\n  if (dir === cwd) {\n    checkCwdSync(cwd);\n    return done();\n  }\n\n  if (preserve) return done(mkdirp.sync(dir, mode));\n  var sub = normPath(path.relative(cwd, dir));\n  var parts = sub.split('/');\n  var created = null;\n\n  for (var p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    part = normPath(path.resolve(part));\n    if (cGet(cache, part)) continue;\n\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cSet(cache, part, true);\n    } catch (er) {\n      var st = fs.lstatSync(part);\n\n      if (st.isDirectory()) {\n        cSet(cache, part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cSet(cache, part, true);\n        continue;\n      } else if (st.isSymbolicLink()) return new SymlinkError(part, part + '/' + parts.join('/'));\n    }\n  }\n\n  return done(created);\n};","map":null,"metadata":{},"sourceType":"script"}