{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\suresoft\\\\Desktop\\\\vomproject\\\\sure-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar MiniPass = require('minipass');\n\nvar Pax = require('./pax.js');\n\nvar Header = require('./header.js');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar normPath = require('./normalize-windows-path.js');\n\nvar stripSlash = require('./strip-trailing-slashes.js');\n\nvar prefixPath = function prefixPath(path, prefix) {\n  if (!prefix) return normPath(path);\n  path = normPath(path).replace(/^\\.(\\/|$)/, '');\n  return stripSlash(prefix) + '/' + path;\n};\n\nvar maxReadSize = 16 * 1024 * 1024;\nvar PROCESS = Symbol('process');\nvar FILE = Symbol('file');\nvar DIRECTORY = Symbol('directory');\nvar SYMLINK = Symbol('symlink');\nvar HARDLINK = Symbol('hardlink');\nvar HEADER = Symbol('header');\nvar READ = Symbol('read');\nvar LSTAT = Symbol('lstat');\nvar ONLSTAT = Symbol('onlstat');\nvar ONREAD = Symbol('onread');\nvar ONREADLINK = Symbol('onreadlink');\nvar OPENFILE = Symbol('openfile');\nvar ONOPENFILE = Symbol('onopenfile');\nvar CLOSE = Symbol('close');\nvar MODE = Symbol('mode');\nvar AWAITDRAIN = Symbol('awaitDrain');\nvar ONDRAIN = Symbol('ondrain');\nvar PREFIX = Symbol('prefix');\nvar HAD_ERROR = Symbol('hadError');\n\nvar warner = require('./warn-mixin.js');\n\nvar winchars = require('./winchars.js');\n\nvar stripAbsolutePath = require('./strip-absolute-path.js');\n\nvar modeFix = require('./mode-fix.js');\n\nvar WriteEntry = warner( /*#__PURE__*/function (_MiniPass) {\n  _inherits(WriteEntry, _MiniPass);\n\n  var _super = _createSuper(WriteEntry);\n\n  function WriteEntry(p, opt) {\n    var _this;\n\n    _classCallCheck(this, WriteEntry);\n\n    opt = opt || {};\n    _this = _super.call(this, opt);\n    if (typeof p !== 'string') throw new TypeError('path is required');\n    _this.path = normPath(p); // suppress atime, ctime, uid, gid, uname, gname\n\n    _this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    _this.myuid = process.getuid && process.getuid() || 0;\n    _this.myuser = process.env.USER || '';\n    _this.maxReadSize = opt.maxReadSize || maxReadSize;\n    _this.linkCache = opt.linkCache || new Map();\n    _this.statCache = opt.statCache || new Map();\n    _this.preservePaths = !!opt.preservePaths;\n    _this.cwd = normPath(opt.cwd || process.cwd());\n    _this.strict = !!opt.strict;\n    _this.noPax = !!opt.noPax;\n    _this.noMtime = !!opt.noMtime;\n    _this.mtime = opt.mtime || null;\n    _this.prefix = opt.prefix ? normPath(opt.prefix) : null;\n    _this.fd = null;\n    _this.blockLen = null;\n    _this.blockRemain = null;\n    _this.buf = null;\n    _this.offset = null;\n    _this.length = null;\n    _this.pos = null;\n    _this.remain = null;\n    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);\n    var pathWarn = false;\n\n    if (!_this.preservePaths) {\n      var _stripAbsolutePath = stripAbsolutePath(_this.path),\n          _stripAbsolutePath2 = _slicedToArray(_stripAbsolutePath, 2),\n          root = _stripAbsolutePath2[0],\n          stripped = _stripAbsolutePath2[1];\n\n      if (root) {\n        _this.path = stripped;\n        pathWarn = root;\n      }\n    }\n\n    _this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (_this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      _this.path = winchars.decode(_this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    _this.absolute = normPath(opt.absolute || path.resolve(_this.cwd, p));\n    if (_this.path === '') _this.path = './';\n\n    if (pathWarn) {\n      _this.warn('TAR_ENTRY_INFO', \"stripping \".concat(pathWarn, \" from absolute path\"), {\n        entry: _assertThisInitialized(_this),\n        path: pathWarn + _this.path\n      });\n    }\n\n    if (_this.statCache.has(_this.absolute)) _this[ONLSTAT](_this.statCache.get(_this.absolute));else _this[LSTAT]();\n    return _this;\n  }\n\n  _createClass(WriteEntry, [{\n    key: \"emit\",\n    value: function emit(ev) {\n      var _get2;\n\n      if (ev === 'error') this[HAD_ERROR] = true;\n\n      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(WriteEntry.prototype), \"emit\", this)).call.apply(_get2, [this, ev].concat(data));\n    }\n  }, {\n    key: LSTAT,\n    value: function value() {\n      var _this2 = this;\n\n      fs.lstat(this.absolute, function (er, stat) {\n        if (er) return _this2.emit('error', er);\n\n        _this2[ONLSTAT](stat);\n      });\n    }\n  }, {\n    key: ONLSTAT,\n    value: function value(stat) {\n      this.statCache.set(this.absolute, stat);\n      this.stat = stat;\n      if (!stat.isFile()) stat.size = 0;\n      this.type = getType(stat);\n      this.emit('stat', stat);\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESS,\n    value: function value() {\n      switch (this.type) {\n        case 'File':\n          return this[FILE]();\n\n        case 'Directory':\n          return this[DIRECTORY]();\n\n        case 'SymbolicLink':\n          return this[SYMLINK]();\n        // unsupported types are ignored.\n\n        default:\n          return this.end();\n      }\n    }\n  }, {\n    key: MODE,\n    value: function value(mode) {\n      return modeFix(mode, this.type === 'Directory', this.portable);\n    }\n  }, {\n    key: PREFIX,\n    value: function value(path) {\n      return prefixPath(path, this.prefix);\n    }\n  }, {\n    key: HEADER,\n    value: function value() {\n      if (this.type === 'Directory' && this.portable) this.noMtime = true;\n      this.header = new Header({\n        path: this[PREFIX](this.path),\n        // only apply the prefix to hard links.\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n        // only the permissions and setuid/setgid/sticky bitflags\n        // not the higher-order bits that specify file type\n        mode: this[MODE](this.stat.mode),\n        uid: this.portable ? null : this.stat.uid,\n        gid: this.portable ? null : this.stat.gid,\n        size: this.stat.size,\n        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n        type: this.type,\n        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n        atime: this.portable ? null : this.stat.atime,\n        ctime: this.portable ? null : this.stat.ctime\n      });\n\n      if (this.header.encode() && !this.noPax) {\n        _get(_getPrototypeOf(WriteEntry.prototype), \"write\", this).call(this, new Pax({\n          atime: this.portable ? null : this.header.atime,\n          ctime: this.portable ? null : this.header.ctime,\n          gid: this.portable ? null : this.header.gid,\n          mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n          path: this[PREFIX](this.path),\n          linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n          size: this.header.size,\n          uid: this.portable ? null : this.header.uid,\n          uname: this.portable ? null : this.header.uname,\n          dev: this.portable ? null : this.stat.dev,\n          ino: this.portable ? null : this.stat.ino,\n          nlink: this.portable ? null : this.stat.nlink\n        }).encode());\n      }\n\n      _get(_getPrototypeOf(WriteEntry.prototype), \"write\", this).call(this, this.header.block);\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value() {\n      if (this.path.substr(-1) !== '/') this.path += '/';\n      this.stat.size = 0;\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: SYMLINK,\n    value: function value() {\n      var _this3 = this;\n\n      fs.readlink(this.absolute, function (er, linkpath) {\n        if (er) return _this3.emit('error', er);\n\n        _this3[ONREADLINK](linkpath);\n      });\n    }\n  }, {\n    key: ONREADLINK,\n    value: function value(linkpath) {\n      this.linkpath = normPath(linkpath);\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: HARDLINK,\n    value: function value(linkpath) {\n      this.type = 'Link';\n      this.linkpath = normPath(path.relative(this.cwd, linkpath));\n      this.stat.size = 0;\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: FILE,\n    value: function value() {\n      if (this.stat.nlink > 1) {\n        var linkKey = this.stat.dev + ':' + this.stat.ino;\n\n        if (this.linkCache.has(linkKey)) {\n          var linkpath = this.linkCache.get(linkKey);\n          if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);\n        }\n\n        this.linkCache.set(linkKey, this.absolute);\n      }\n\n      this[HEADER]();\n      if (this.stat.size === 0) return this.end();\n      this[OPENFILE]();\n    }\n  }, {\n    key: OPENFILE,\n    value: function value() {\n      var _this4 = this;\n\n      fs.open(this.absolute, 'r', function (er, fd) {\n        if (er) return _this4.emit('error', er);\n\n        _this4[ONOPENFILE](fd);\n      });\n    }\n  }, {\n    key: ONOPENFILE,\n    value: function value(fd) {\n      this.fd = fd;\n      if (this[HAD_ERROR]) return this[CLOSE]();\n      this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n      this.blockRemain = this.blockLen;\n      var bufLen = Math.min(this.blockLen, this.maxReadSize);\n      this.buf = Buffer.allocUnsafe(bufLen);\n      this.offset = 0;\n      this.pos = 0;\n      this.remain = this.stat.size;\n      this.length = this.buf.length;\n      this[READ]();\n    }\n  }, {\n    key: READ,\n    value: function value() {\n      var _this5 = this;\n\n      var fd = this.fd,\n          buf = this.buf,\n          offset = this.offset,\n          length = this.length,\n          pos = this.pos;\n      fs.read(fd, buf, offset, length, pos, function (er, bytesRead) {\n        if (er) {\n          // ignoring the error from close(2) is a bad practice, but at\n          // this point we already have an error, don't need another one\n          return _this5[CLOSE](function () {\n            return _this5.emit('error', er);\n          });\n        }\n\n        _this5[ONREAD](bytesRead);\n      });\n    }\n  }, {\n    key: CLOSE,\n    value: function value(cb) {\n      fs.close(this.fd, cb);\n    }\n  }, {\n    key: ONREAD,\n    value: function value(bytesRead) {\n      var _this6 = this;\n\n      if (bytesRead <= 0 && this.remain > 0) {\n        var er = new Error('encountered unexpected EOF');\n        er.path = this.absolute;\n        er.syscall = 'read';\n        er.code = 'EOF';\n        return this[CLOSE](function () {\n          return _this6.emit('error', er);\n        });\n      }\n\n      if (bytesRead > this.remain) {\n        var _er = new Error('did not encounter expected EOF');\n\n        _er.path = this.absolute;\n        _er.syscall = 'read';\n        _er.code = 'EOF';\n        return this[CLOSE](function () {\n          return _this6.emit('error', _er);\n        });\n      } // null out the rest of the buffer, if we could fit the block padding\n      // at the end of this loop, we've incremented bytesRead and this.remain\n      // to be incremented up to the blockRemain level, as if we had expected\n      // to get a null-padded file, and read it until the end.  then we will\n      // decrement both remain and blockRemain by bytesRead, and know that we\n      // reached the expected EOF, without any null buffer to append.\n\n\n      if (bytesRead === this.remain) {\n        for (var i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n          this.buf[i + this.offset] = 0;\n          bytesRead++;\n          this.remain++;\n        }\n      }\n\n      var writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);\n      var flushed = this.write(writeBuf);\n      if (!flushed) this[AWAITDRAIN](function () {\n        return _this6[ONDRAIN]();\n      });else this[ONDRAIN]();\n    }\n  }, {\n    key: AWAITDRAIN,\n    value: function value(cb) {\n      this.once('drain', cb);\n    }\n  }, {\n    key: \"write\",\n    value: function write(writeBuf) {\n      if (this.blockRemain < writeBuf.length) {\n        var er = new Error('writing more data than expected');\n        er.path = this.absolute;\n        return this.emit('error', er);\n      }\n\n      this.remain -= writeBuf.length;\n      this.blockRemain -= writeBuf.length;\n      this.pos += writeBuf.length;\n      this.offset += writeBuf.length;\n      return _get(_getPrototypeOf(WriteEntry.prototype), \"write\", this).call(this, writeBuf);\n    }\n  }, {\n    key: ONDRAIN,\n    value: function value() {\n      var _this7 = this;\n\n      if (!this.remain) {\n        if (this.blockRemain) _get(_getPrototypeOf(WriteEntry.prototype), \"write\", this).call(this, Buffer.alloc(this.blockRemain));\n        return this[CLOSE](function (er) {\n          return er ? _this7.emit('error', er) : _this7.end();\n        });\n      }\n\n      if (this.offset >= this.length) {\n        // if we only have a smaller bit left to read, alloc a smaller buffer\n        // otherwise, keep it the same length it was before.\n        this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n        this.offset = 0;\n      }\n\n      this.length = this.buf.length - this.offset;\n      this[READ]();\n    }\n  }]);\n\n  return WriteEntry;\n}(MiniPass));\n\nvar WriteEntrySync = /*#__PURE__*/function (_WriteEntry) {\n  _inherits(WriteEntrySync, _WriteEntry);\n\n  var _super2 = _createSuper(WriteEntrySync);\n\n  function WriteEntrySync() {\n    _classCallCheck(this, WriteEntrySync);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(WriteEntrySync, [{\n    key: LSTAT,\n    value: function value() {\n      this[ONLSTAT](fs.lstatSync(this.absolute));\n    }\n  }, {\n    key: SYMLINK,\n    value: function value() {\n      this[ONREADLINK](fs.readlinkSync(this.absolute));\n    }\n  }, {\n    key: OPENFILE,\n    value: function value() {\n      this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n    }\n  }, {\n    key: READ,\n    value: function value() {\n      var threw = true;\n\n      try {\n        var fd = this.fd,\n            buf = this.buf,\n            offset = this.offset,\n            length = this.length,\n            pos = this.pos;\n        var bytesRead = fs.readSync(fd, buf, offset, length, pos);\n        this[ONREAD](bytesRead);\n        threw = false;\n      } finally {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        if (threw) {\n          try {\n            this[CLOSE](function () {});\n          } catch (er) {}\n        }\n      }\n    }\n  }, {\n    key: AWAITDRAIN,\n    value: function value(cb) {\n      cb();\n    }\n  }, {\n    key: CLOSE,\n    value: function value(cb) {\n      fs.closeSync(this.fd);\n      cb();\n    }\n  }]);\n\n  return WriteEntrySync;\n}(WriteEntry);\n\nvar WriteEntryTar = warner( /*#__PURE__*/function (_MiniPass2) {\n  _inherits(WriteEntryTar, _MiniPass2);\n\n  var _super3 = _createSuper(WriteEntryTar);\n\n  function WriteEntryTar(readEntry, opt) {\n    var _thisSuper, _thisSuper2, _this8;\n\n    _classCallCheck(this, WriteEntryTar);\n\n    opt = opt || {};\n    _this8 = _super3.call(this, opt);\n    _this8.preservePaths = !!opt.preservePaths;\n    _this8.portable = !!opt.portable;\n    _this8.strict = !!opt.strict;\n    _this8.noPax = !!opt.noPax;\n    _this8.noMtime = !!opt.noMtime;\n    _this8.readEntry = readEntry;\n    _this8.type = readEntry.type;\n    if (_this8.type === 'Directory' && _this8.portable) _this8.noMtime = true;\n    _this8.prefix = opt.prefix || null;\n    _this8.path = normPath(readEntry.path);\n    _this8.mode = _this8[MODE](readEntry.mode);\n    _this8.uid = _this8.portable ? null : readEntry.uid;\n    _this8.gid = _this8.portable ? null : readEntry.gid;\n    _this8.uname = _this8.portable ? null : readEntry.uname;\n    _this8.gname = _this8.portable ? null : readEntry.gname;\n    _this8.size = readEntry.size;\n    _this8.mtime = _this8.noMtime ? null : opt.mtime || readEntry.mtime;\n    _this8.atime = _this8.portable ? null : readEntry.atime;\n    _this8.ctime = _this8.portable ? null : readEntry.ctime;\n    _this8.linkpath = normPath(readEntry.linkpath);\n    if (typeof opt.onwarn === 'function') _this8.on('warn', opt.onwarn);\n    var pathWarn = false;\n\n    if (!_this8.preservePaths) {\n      var _stripAbsolutePath3 = stripAbsolutePath(_this8.path),\n          _stripAbsolutePath4 = _slicedToArray(_stripAbsolutePath3, 2),\n          root = _stripAbsolutePath4[0],\n          stripped = _stripAbsolutePath4[1];\n\n      if (root) {\n        _this8.path = stripped;\n        pathWarn = root;\n      }\n    }\n\n    _this8.remain = readEntry.size;\n    _this8.blockRemain = readEntry.startBlockSize;\n    _this8.header = new Header({\n      path: _this8[PREFIX](_this8.path),\n      linkpath: _this8.type === 'Link' ? _this8[PREFIX](_this8.linkpath) : _this8.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: _this8.mode,\n      uid: _this8.portable ? null : _this8.uid,\n      gid: _this8.portable ? null : _this8.gid,\n      size: _this8.size,\n      mtime: _this8.noMtime ? null : _this8.mtime,\n      type: _this8.type,\n      uname: _this8.portable ? null : _this8.uname,\n      atime: _this8.portable ? null : _this8.atime,\n      ctime: _this8.portable ? null : _this8.ctime\n    });\n\n    if (pathWarn) {\n      _this8.warn('TAR_ENTRY_INFO', \"stripping \".concat(pathWarn, \" from absolute path\"), {\n        entry: _assertThisInitialized(_this8),\n        path: pathWarn + _this8.path\n      });\n    }\n\n    if (_this8.header.encode() && !_this8.noPax) {\n      _get((_thisSuper = _assertThisInitialized(_this8), _getPrototypeOf(WriteEntryTar.prototype)), \"write\", _thisSuper).call(_thisSuper, new Pax({\n        atime: _this8.portable ? null : _this8.atime,\n        ctime: _this8.portable ? null : _this8.ctime,\n        gid: _this8.portable ? null : _this8.gid,\n        mtime: _this8.noMtime ? null : _this8.mtime,\n        path: _this8[PREFIX](_this8.path),\n        linkpath: _this8.type === 'Link' ? _this8[PREFIX](_this8.linkpath) : _this8.linkpath,\n        size: _this8.size,\n        uid: _this8.portable ? null : _this8.uid,\n        uname: _this8.portable ? null : _this8.uname,\n        dev: _this8.portable ? null : _this8.readEntry.dev,\n        ino: _this8.portable ? null : _this8.readEntry.ino,\n        nlink: _this8.portable ? null : _this8.readEntry.nlink\n      }).encode());\n    }\n\n    _get((_thisSuper2 = _assertThisInitialized(_this8), _getPrototypeOf(WriteEntryTar.prototype)), \"write\", _thisSuper2).call(_thisSuper2, _this8.header.block);\n\n    readEntry.pipe(_assertThisInitialized(_this8));\n    return _this8;\n  }\n\n  _createClass(WriteEntryTar, [{\n    key: PREFIX,\n    value: function value(path) {\n      return prefixPath(path, this.prefix);\n    }\n  }, {\n    key: MODE,\n    value: function value(mode) {\n      return modeFix(mode, this.type === 'Directory', this.portable);\n    }\n  }, {\n    key: \"write\",\n    value: function write(data) {\n      var writeLen = data.length;\n      if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n      this.blockRemain -= writeLen;\n      return _get(_getPrototypeOf(WriteEntryTar.prototype), \"write\", this).call(this, data);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.blockRemain) _get(_getPrototypeOf(WriteEntryTar.prototype), \"write\", this).call(this, Buffer.alloc(this.blockRemain));\n      return _get(_getPrototypeOf(WriteEntryTar.prototype), \"end\", this).call(this);\n    }\n  }]);\n\n  return WriteEntryTar;\n}(MiniPass));\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nvar getType = function getType(stat) {\n  return stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n};\n\nmodule.exports = WriteEntry;","map":null,"metadata":{},"sourceType":"script"}