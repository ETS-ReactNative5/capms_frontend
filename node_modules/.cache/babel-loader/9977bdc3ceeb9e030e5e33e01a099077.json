{"ast":null,"code":"'use strict'; // Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nvar encode = function encode(num, buf) {\n  if (!Number.isSafeInteger(num)) // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('cannot encode number outside of javascript safe integer range');else if (num < 0) encodeNegative(num, buf);else encodePositive(num, buf);\n  return buf;\n};\n\nvar encodePositive = function encodePositive(num, buf) {\n  buf[0] = 0x80;\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff;\n    num = Math.floor(num / 0x100);\n  }\n};\n\nvar encodeNegative = function encodeNegative(num, buf) {\n  buf[0] = 0xff;\n  var flipped = false;\n  num = num * -1;\n\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff;\n    num = Math.floor(num / 0x100);\n    if (flipped) buf[i - 1] = onesComp(byte);else if (byte === 0) buf[i - 1] = 0;else {\n      flipped = true;\n      buf[i - 1] = twosComp(byte);\n    }\n  }\n};\n\nvar parse = function parse(buf) {\n  var pre = buf[0];\n  var value = pre === 0x80 ? pos(buf.slice(1, buf.length)) : pre === 0xff ? twos(buf) : null;\n  if (value === null) throw Error('invalid base256 encoding');\n  if (!Number.isSafeInteger(value)) // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('parsed number outside of javascript safe integer range');\n  return value;\n};\n\nvar twos = function twos(buf) {\n  var len = buf.length;\n  var sum = 0;\n  var flipped = false;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    var f;\n    if (flipped) f = onesComp(byte);else if (byte === 0) f = byte;else {\n      flipped = true;\n      f = twosComp(byte);\n    }\n    if (f !== 0) sum -= f * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nvar pos = function pos(buf) {\n  var len = buf.length;\n  var sum = 0;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    if (byte !== 0) sum += byte * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nvar onesComp = function onesComp(byte) {\n  return (0xff ^ byte) & 0xff;\n};\n\nvar twosComp = function twosComp(byte) {\n  return (0xff ^ byte) + 1 & 0xff;\n};\n\nmodule.exports = {\n  encode: encode,\n  parse: parse\n};","map":null,"metadata":{},"sourceType":"script"}