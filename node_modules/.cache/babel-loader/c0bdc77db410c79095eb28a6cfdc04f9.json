{"ast":null,"code":"/*\n Highcharts Gantt JS v9.3.1 (2021-11-05)\n\n Gantt series\n\n (c) 2016-2021 Lars A. V. Cabrera\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (b) {\n  \"object\" === typeof module && module.exports ? (b[\"default\"] = b, module.exports = b) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/gantt\", [\"highcharts\"], function (J) {\n    b(J);\n    b.Highcharts = J;\n    return b;\n  }) : b(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (b) {\n  function J(b, t, v, u) {\n    b.hasOwnProperty(t) || (b[t] = u.apply(null, v));\n  }\n\n  b = b ? b._modules : {};\n  J(b, \"Series/XRange/XRangePoint.js\", [b[\"Core/Series/Point.js\"], b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Utilities.js\"]], function (b, t, v) {\n    var u = this && this.__extends || function () {\n      var _b = function b(l, h) {\n        _b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (h, d) {\n          h.__proto__ = d;\n        } || function (h, d) {\n          for (var p in d) {\n            d.hasOwnProperty(p) && (h[p] = d[p]);\n          }\n        };\n\n        return _b(l, h);\n      };\n\n      return function (l, h) {\n        function x() {\n          this.constructor = l;\n        }\n\n        _b(l, h);\n\n        l.prototype = null === h ? Object.create(h) : (x.prototype = h.prototype, new x());\n      };\n    }();\n\n    v = v.extend;\n\n    t = function (t) {\n      function l() {\n        var h = null !== t && t.apply(this, arguments) || this;\n        h.options = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      u(l, t);\n\n      l.getColorByCategory = function (h, l) {\n        var d = h.options.colors || h.chart.options.colors;\n        h = l.y % (d ? d.length : h.chart.options.chart.colorCount);\n        return {\n          colorIndex: h,\n          color: d && d[h]\n        };\n      };\n\n      l.prototype.resolveColor = function () {\n        var h = this.series;\n\n        if (h.options.colorByPoint && !this.options.color) {\n          var x = l.getColorByCategory(h, this);\n          h.chart.styledMode || (this.color = x.color);\n          this.options.colorIndex || (this.colorIndex = x.colorIndex);\n        } else this.color || (this.color = h.color);\n      };\n\n      l.prototype.init = function () {\n        b.prototype.init.apply(this, arguments);\n        this.y || (this.y = 0);\n        return this;\n      };\n\n      l.prototype.setState = function () {\n        b.prototype.setState.apply(this, arguments);\n        this.series.drawPoint(this, this.series.getAnimationVerb());\n      };\n\n      l.prototype.getLabelConfig = function () {\n        var h = b.prototype.getLabelConfig.call(this),\n            l = this.series.yAxis.categories;\n        h.x2 = this.x2;\n        h.yCategory = this.yCategory = l && l[this.y];\n        return h;\n      };\n\n      l.prototype.isValid = function () {\n        return \"number\" === typeof this.x && \"number\" === typeof this.x2;\n      };\n\n      return l;\n    }(t.seriesTypes.column.prototype.pointClass);\n\n    v(t.prototype, {\n      ttBelow: !1,\n      tooltipDateKeys: [\"x\", \"x2\"]\n    });\n    return t;\n  });\n  J(b, \"Series/XRange/XRangeComposition.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Utilities.js\"]], function (b, t) {\n    var v = t.addEvent,\n        u = t.pick;\n    v(b, \"afterGetSeriesExtremes\", function () {\n      var b = this.series,\n          l;\n\n      if (this.isXAxis) {\n        var h = u(this.dataMax, -Number.MAX_VALUE);\n        b.forEach(function (b) {\n          b.x2Data && b.x2Data.forEach(function (d) {\n            d > h && (h = d, l = !0);\n          });\n        });\n        l && (this.dataMax = h);\n      }\n    });\n  });\n  J(b, \"Series/XRange/XRangeSeries.js\", [b[\"Core/Globals.js\"], b[\"Core/Color/Color.js\"], b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Utilities.js\"], b[\"Series/XRange/XRangePoint.js\"]], function (b, t, v, u, B) {\n    var l = this && this.__extends || function () {\n      var _a = function a(c, m) {\n        _a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (m, a) {\n          m.__proto__ = a;\n        } || function (m, a) {\n          for (var c in a) {\n            a.hasOwnProperty(c) && (m[c] = a[c]);\n          }\n        };\n\n        return _a(c, m);\n      };\n\n      return function (c, m) {\n        function C() {\n          this.constructor = c;\n        }\n\n        _a(c, m);\n\n        c.prototype = null === m ? Object.create(m) : (C.prototype = m.prototype, new C());\n      };\n    }(),\n        h = t.parse,\n        x = v.series,\n        d = v.seriesTypes.column,\n        p = d.prototype,\n        g = u.clamp,\n        A = u.correctFloat,\n        D = u.defined;\n\n    t = u.extend;\n    var H = u.find,\n        e = u.isNumber,\n        a = u.isObject,\n        c = u.merge,\n        r = u.pick;\n\n    u = function (F) {\n      function G() {\n        var a = null !== F && F.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      l(G, F);\n\n      G.prototype.init = function () {\n        d.prototype.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      };\n\n      G.prototype.getColumnMetrics = function () {\n        function a() {\n          c.series.forEach(function (a) {\n            var m = a.xAxis;\n            a.xAxis = a.yAxis;\n            a.yAxis = m;\n          });\n        }\n\n        var c = this.chart;\n        a();\n        var r = p.getColumnMetrics.call(this);\n        a();\n        return r;\n      };\n\n      G.prototype.cropData = function (a, c, r, e) {\n        c = x.prototype.cropData.call(this, this.x2Data, c, r, e);\n        c.xData = a.slice(c.start, c.end);\n        return c;\n      };\n\n      G.prototype.findPointIndex = function (a) {\n        var m = this.cropped,\n            c = this.cropStart,\n            r = this.points,\n            g = a.id;\n        if (g) var d = (d = H(r, function (a) {\n          return a.id === g;\n        })) ? d.index : void 0;\n        \"undefined\" === typeof d && (d = (d = H(r, function (m) {\n          return m.x === a.x && m.x2 === a.x2 && !m.touched;\n        })) ? d.index : void 0);\n        m && e(d) && e(c) && d >= c && (d -= c);\n        return d;\n      };\n\n      G.prototype.translatePoint = function (m) {\n        var C = this.xAxis,\n            d = this.yAxis,\n            F = this.columnMetrics,\n            E = this.options,\n            h = E.minPointLength || 0,\n            p = (m.shapeArgs && m.shapeArgs.width || 0) / 2,\n            z = this.pointXOffset = F.offset,\n            n = m.plotX,\n            y = r(m.x2, m.x + (m.len || 0)),\n            q = C.translate(y, 0, 0, 0, 1);\n        y = Math.abs(q - n);\n        var f = this.chart.inverted,\n            k = r(E.borderWidth, 1) % 2 / 2,\n            w = F.offset,\n            L = Math.round(F.width);\n        h && (h -= y, 0 > h && (h = 0), n -= h / 2, q += h / 2);\n        n = Math.max(n, -10);\n        q = g(q, -10, C.len + 10);\n        D(m.options.pointWidth) && (w -= (Math.ceil(m.options.pointWidth) - L) / 2, L = Math.ceil(m.options.pointWidth));\n        E.pointPlacement && e(m.plotY) && d.categories && (m.plotY = d.translate(m.y, 0, 1, 0, 1, E.pointPlacement));\n        E = Math.floor(Math.min(n, q)) + k;\n        E = {\n          x: E,\n          y: Math.floor(m.plotY + w) + k,\n          width: Math.floor(Math.max(n, q)) + k - E,\n          height: L,\n          r: this.options.borderRadius\n        };\n        m.shapeArgs = E;\n        f ? m.tooltipPos[1] += z + p : m.tooltipPos[0] -= p + z - E.width / 2;\n        p = E.x;\n        z = p + E.width;\n        0 > p || z > C.len ? (p = g(p, 0, C.len), z = g(z, 0, C.len), q = z - p, m.dlBox = c(E, {\n          x: p,\n          width: z - p,\n          centerX: q ? q / 2 : null\n        })) : m.dlBox = null;\n        p = m.tooltipPos;\n        z = f ? 1 : 0;\n        q = f ? 0 : 1;\n        F = this.columnMetrics ? this.columnMetrics.offset : -F.width / 2;\n        p[z] = f ? p[z] + E.width / 2 : p[z] + (C.reversed ? -1 : 0) * E.width;\n        p[q] = g(p[q] + (f ? -1 : 1) * F, 0, d.len - 1);\n        if (d = m.partialFill) a(d) && (d = d.amount), e(d) || (d = 0), m.partShapeArgs = c(E, {\n          r: this.options.borderRadius\n        }), n = Math.max(Math.round(y * d + m.plotX - n), 0), m.clipRectArgs = {\n          x: C.reversed ? E.x + y - n : E.x,\n          y: E.y,\n          width: n,\n          height: E.height\n        };\n      };\n\n      G.prototype.translate = function () {\n        p.translate.apply(this, arguments);\n        this.points.forEach(function (a) {\n          this.translatePoint(a);\n        }, this);\n      };\n\n      G.prototype.drawPoint = function (m, C) {\n        var e = this.options,\n            d = this.chart.renderer,\n            g = m.graphic,\n            p = m.shapeType,\n            F = m.shapeArgs,\n            z = m.partShapeArgs,\n            n = m.clipRectArgs,\n            y = m.partialFill,\n            q = e.stacking && !e.borderRadius,\n            f = m.state,\n            k = e.states[f || \"normal\"] || {},\n            w = \"undefined\" === typeof f ? \"attr\" : C;\n        f = this.pointAttribs(m, f);\n        k = r(this.chart.options.chart.animation, k.animation);\n        if (m.isNull || !1 === m.visible) g && (m.graphic = g.destroy());else {\n          if (g) g.rect[C](F);else m.graphic = g = d.g(\"point\").addClass(m.getClassName()).add(m.group || this.group), g.rect = d[p](c(F)).addClass(m.getClassName()).addClass(\"highcharts-partfill-original\").add(g);\n          z && (g.partRect ? (g.partRect[C](c(z)), g.partialClipRect[C](c(n))) : (g.partialClipRect = d.clipRect(n.x, n.y, n.width, n.height), g.partRect = d[p](z).addClass(\"highcharts-partfill-overlay\").add(g).clip(g.partialClipRect)));\n          this.chart.styledMode || (g.rect[C](f, k).shadow(e.shadow, null, q), z && (a(y) || (y = {}), a(e.partialFill) && (y = c(e.partialFill, y)), m = y.fill || h(f.fill).brighten(-.3).get() || h(m.color || this.color).brighten(-.3).get(), f.fill = m, g.partRect[w](f, k).shadow(e.shadow, null, q)));\n        }\n      };\n\n      G.prototype.drawPoints = function () {\n        var a = this,\n            c = a.getAnimationVerb();\n        a.points.forEach(function (m) {\n          a.drawPoint(m, c);\n        });\n      };\n\n      G.prototype.getAnimationVerb = function () {\n        return this.chart.pointCount < (this.options.animationLimit || 250) ? \"animate\" : \"attr\";\n      };\n\n      G.prototype.isPointInside = function (a) {\n        var c = a.shapeArgs,\n            m = a.plotX,\n            e = a.plotY;\n        return c ? \"undefined\" !== typeof m && \"undefined\" !== typeof e && 0 <= e && e <= this.yAxis.len && 0 <= (c.x || 0) + (c.width || 0) && m <= this.xAxis.len : F.prototype.isPointInside.apply(this, arguments);\n      };\n\n      G.defaultOptions = c(d.defaultOptions, {\n        colorByPoint: !0,\n        dataLabels: {\n          formatter: function formatter() {\n            var c = this.point.partialFill;\n            a(c) && (c = c.amount);\n            if (e(c) && 0 < c) return A(100 * c) + \"%\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        tooltip: {\n          headerFormat: '<span style=\"font-size: 10px\">{point.x} - {point.x2}</span><br/>',\n          pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>\"\n        },\n        borderRadius: 3,\n        pointRange: 0\n      });\n      return G;\n    }(d);\n\n    t(u.prototype, {\n      type: \"xrange\",\n      parallelArrays: [\"x\", \"x2\", \"y\"],\n      requireSorting: !1,\n      animate: x.prototype.animate,\n      cropShoulder: 1,\n      getExtremesFromAll: !0,\n      autoIncrement: b.noop,\n      buildKDTree: b.noop,\n      pointClass: B\n    });\n    v.registerSeriesType(\"xrange\", u);\n    \"\";\n    return u;\n  });\n  J(b, \"Series/Gantt/GanttPoint.js\", [b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Utilities.js\"]], function (b, t) {\n    var v = this && this.__extends || function () {\n      var _b2 = function b(l, h) {\n        _b2 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (h, d) {\n          h.__proto__ = d;\n        } || function (h, d) {\n          for (var p in d) {\n            d.hasOwnProperty(p) && (h[p] = d[p]);\n          }\n        };\n\n        return _b2(l, h);\n      };\n\n      return function (l, h) {\n        function x() {\n          this.constructor = l;\n        }\n\n        _b2(l, h);\n\n        l.prototype = null === h ? Object.create(h) : (x.prototype = h.prototype, new x());\n      };\n    }(),\n        u = t.pick;\n\n    return function (b) {\n      function l() {\n        var h = null !== b && b.apply(this, arguments) || this;\n        h.options = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      v(l, b);\n\n      l.setGanttPointAliases = function (h) {\n        function b(d, p) {\n          \"undefined\" !== typeof p && (h[d] = p);\n        }\n\n        b(\"x\", u(h.start, h.x));\n        b(\"x2\", u(h.end, h.x2));\n        b(\"partialFill\", u(h.completed, h.partialFill));\n      };\n\n      l.prototype.applyOptions = function (h, x) {\n        h = b.prototype.applyOptions.call(this, h, x);\n        l.setGanttPointAliases(h);\n        return h;\n      };\n\n      l.prototype.isValid = function () {\n        return (\"number\" === typeof this.start || \"number\" === typeof this.x) && (\"number\" === typeof this.end || \"number\" === typeof this.x2 || this.milestone);\n      };\n\n      return l;\n    }(b.seriesTypes.xrange.prototype.pointClass);\n  });\n  J(b, \"Core/Axis/BrokenAxis.js\", [b[\"Extensions/Stacking.js\"], b[\"Core/Utilities.js\"]], function (b, t) {\n    var v = t.addEvent,\n        u = t.find,\n        B = t.fireEvent,\n        l = t.isArray,\n        h = t.isNumber,\n        x = t.pick,\n        d;\n\n    (function (d) {\n      function g() {\n        \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n\n      function p() {\n        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n      }\n\n      function D() {\n        var a = this.brokenAxis;\n\n        if (a && a.hasBreaks) {\n          for (var c = this.tickPositions, e = this.tickPositions.info, r = [], g = 0; g < c.length; g++) {\n            a.isInAnyBreak(c[g]) || r.push(c[g]);\n          }\n\n          this.tickPositions = r;\n          this.tickPositions.info = e;\n        }\n      }\n\n      function H() {\n        this.brokenAxis || (this.brokenAxis = new G(this));\n      }\n\n      function e() {\n        var a = this.options.connectNulls,\n            c = this.points,\n            e = this.xAxis,\n            g = this.yAxis;\n        if (this.isDirty) for (var r = c.length; r--;) {\n          var d = c[r],\n              p = !(null === d.y && !1 === a) && (e && e.brokenAxis && e.brokenAxis.isInAnyBreak(d.x, !0) || g && g.brokenAxis && g.brokenAxis.isInAnyBreak(d.y, !0));\n          d.visible = p ? !1 : !1 !== d.options.visible;\n        }\n      }\n\n      function a() {\n        this.drawBreaks(this.xAxis, [\"x\"]);\n        this.drawBreaks(this.yAxis, x(this.pointArrayMap, [\"y\"]));\n      }\n\n      function c(a, c) {\n        var m = this,\n            e = m.points,\n            g,\n            r,\n            d,\n            z;\n\n        if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {\n          var n = a.brokenAxis;\n          c.forEach(function (c) {\n            g = n && n.breakArray || [];\n            r = a.isXAxis ? a.min : x(m.options.threshold, a.min);\n            e.forEach(function (n) {\n              z = x(n[\"stack\" + c.toUpperCase()], n[c]);\n              g.forEach(function (f) {\n                if (h(r) && h(z)) {\n                  d = !1;\n                  if (r < f.from && z > f.to || r > f.from && z < f.from) d = \"pointBreak\";else if (r < f.from && z > f.from && z < f.to || r > f.from && z > f.to && z < f.from) d = \"pointInBreak\";\n                  d && B(a, d, {\n                    point: n,\n                    brk: f\n                  });\n                }\n              });\n            });\n          });\n        }\n      }\n\n      function r() {\n        var a = this.currentDataGrouping,\n            c = a && a.gapSize;\n        a = this.points.slice();\n        var e = this.yAxis,\n            r = this.options.gapSize,\n            g = a.length - 1,\n            d;\n        if (r && 0 < g) for (\"value\" !== this.options.gapUnit && (r *= this.basePointRange), c && c > r && c >= this.basePointRange && (r = c), d = void 0; g--;) {\n          d && !1 !== d.visible || (d = a[g + 1]), c = a[g], !1 !== d.visible && !1 !== c.visible && (d.x - c.x > r && (d = (c.x + d.x) / 2, a.splice(g + 1, 0, {\n            isNull: !0,\n            x: d\n          }), e.stacking && this.options.stacking && (d = e.stacking.stacks[this.stackKey][d] = new b(e, e.options.stackLabels, !1, d, this.stack), d.total = 0)), d = c);\n        }\n        return this.getGraphPath(a);\n      }\n\n      var F = [];\n\n      d.compose = function (m, d) {\n        -1 === F.indexOf(m) && (F.push(m), m.keepProps.push(\"brokenAxis\"), v(m, \"init\", H), v(m, \"afterInit\", g), v(m, \"afterSetTickPositions\", D), v(m, \"afterSetOptions\", p));\n\n        if (-1 === F.indexOf(d)) {\n          F.push(d);\n          var C = d.prototype;\n          C.drawBreaks = c;\n          C.gappedPath = r;\n          v(d, \"afterGeneratePoints\", e);\n          v(d, \"afterRender\", a);\n        }\n\n        return m;\n      };\n\n      var G = function () {\n        function a(a) {\n          this.hasBreaks = !1;\n          this.axis = a;\n        }\n\n        a.isInBreak = function (a, c) {\n          var d = a.repeat || Infinity,\n              r = a.from,\n              e = a.to - a.from;\n          c = c >= r ? (c - r) % d : d - (r - c) % d;\n          return a.inclusive ? c <= e : c < e && 0 !== c;\n        };\n\n        a.lin2Val = function (c) {\n          var d = this.brokenAxis;\n          d = d && d.breakArray;\n          if (!d || !h(c)) return c;\n          var r;\n\n          for (r = 0; r < d.length; r++) {\n            var e = d[r];\n            if (e.from >= c) break;else e.to < c ? c += e.len : a.isInBreak(e, c) && (c += e.len);\n          }\n\n          return c;\n        };\n\n        a.val2Lin = function (c) {\n          var d = this.brokenAxis;\n          d = d && d.breakArray;\n          if (!d || !h(c)) return c;\n          var r = c,\n              e;\n\n          for (e = 0; e < d.length; e++) {\n            var g = d[e];\n            if (g.to <= c) r -= g.len;else if (g.from >= c) break;else if (a.isInBreak(g, c)) {\n              r -= c - g.from;\n              break;\n            }\n          }\n\n          return r;\n        };\n\n        a.prototype.findBreakAt = function (a, c) {\n          return u(c, function (c) {\n            return c.from < a && a < c.to;\n          });\n        };\n\n        a.prototype.isInAnyBreak = function (c, d) {\n          var e = this.axis,\n              r = e.options.breaks || [],\n              g = r.length,\n              m;\n\n          if (g && h(c)) {\n            for (; g--;) {\n              if (a.isInBreak(r[g], c)) {\n                var z = !0;\n                m || (m = x(r[g].showPoints, !e.isXAxis));\n              }\n            }\n\n            var n = z && d ? z && !m : z;\n          }\n\n          return n;\n        };\n\n        a.prototype.setBreaks = function (c, d) {\n          var r = this,\n              e = r.axis,\n              g = l(c) && !!c.length;\n          e.isDirty = r.hasBreaks !== g;\n          r.hasBreaks = g;\n          e.options.breaks = e.userOptions.breaks = c;\n          e.forceRedraw = !0;\n          e.series.forEach(function (a) {\n            a.isDirty = !0;\n          });\n          g || e.val2lin !== a.val2Lin || (delete e.val2lin, delete e.lin2val);\n          g && (e.userOptions.ordinal = !1, e.lin2val = a.lin2Val, e.val2lin = a.val2Lin, e.setExtremes = function (a, c, n, y, q) {\n            if (r.hasBreaks) {\n              for (var f = this.options.breaks || [], k; k = r.findBreakAt(a, f);) {\n                a = k.to;\n              }\n\n              for (; k = r.findBreakAt(c, f);) {\n                c = k.from;\n              }\n\n              c < a && (c = a);\n            }\n\n            e.constructor.prototype.setExtremes.call(this, a, c, n, y, q);\n          }, e.setAxisTranslation = function () {\n            e.constructor.prototype.setAxisTranslation.call(this);\n            r.unitLength = void 0;\n\n            if (r.hasBreaks) {\n              var c = e.options.breaks || [],\n                  d = [],\n                  n = [],\n                  y = x(e.pointRangePadding, 0),\n                  q = 0,\n                  f,\n                  k = e.userMin || e.min,\n                  w = e.userMax || e.max,\n                  g;\n              c.forEach(function (c) {\n                f = c.repeat || Infinity;\n                h(k) && h(w) && (a.isInBreak(c, k) && (k += c.to % f - k % f), a.isInBreak(c, w) && (w -= w % f - c.from % f));\n              });\n              c.forEach(function (a) {\n                O = a.from;\n                f = a.repeat || Infinity;\n\n                if (h(k) && h(w)) {\n                  for (; O - f > k;) {\n                    O -= f;\n                  }\n\n                  for (; O < k;) {\n                    O += f;\n                  }\n\n                  for (g = O; g < w; g += f) {\n                    d.push({\n                      value: g,\n                      move: \"in\"\n                    }), d.push({\n                      value: g + a.to - a.from,\n                      move: \"out\",\n                      size: a.breakSize\n                    });\n                  }\n                }\n              });\n              d.sort(function (f, k) {\n                return f.value === k.value ? (\"in\" === f.move ? 0 : 1) - (\"in\" === k.move ? 0 : 1) : f.value - k.value;\n              });\n              var N = 0;\n              var O = k;\n              d.forEach(function (f) {\n                N += \"in\" === f.move ? 1 : -1;\n                1 === N && \"in\" === f.move && (O = f.value);\n                0 === N && h(O) && (n.push({\n                  from: O,\n                  to: f.value,\n                  len: f.value - O - (f.size || 0)\n                }), q += f.value - O - (f.size || 0));\n              });\n              r.breakArray = n;\n              h(k) && h(w) && h(e.min) && (r.unitLength = w - k - q + y, B(e, \"afterBreaks\"), e.staticScale ? e.transA = e.staticScale : r.unitLength && (e.transA *= (w - e.min + y) / r.unitLength), y && (e.minPixelPadding = e.transA * (e.minPointOffset || 0)), e.min = k, e.max = w);\n            }\n          });\n          x(d, !0) && e.chart.redraw();\n        };\n\n        return a;\n      }();\n\n      d.Additions = G;\n    })(d || (d = {}));\n\n    return d;\n  });\n  J(b, \"Core/Axis/GridAxis.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Axis/AxisDefaults.js\"], b[\"Core/Globals.js\"], b[\"Core/Utilities.js\"]], function (b, t, v, u) {\n    var B = v.dateFormats,\n        l = u.addEvent,\n        h = u.defined,\n        x = u.erase,\n        d = u.find,\n        p = u.isArray,\n        g = u.isNumber,\n        A = u.merge,\n        D = u.pick,\n        H = u.timeUnits,\n        e = u.wrap,\n        a;\n\n    (function (a) {\n      function c(f, k) {\n        var a = {\n          width: 0,\n          height: 0\n        };\n        k.forEach(function (k) {\n          k = f[k];\n\n          if (u.isObject(k, !0)) {\n            var c = u.isObject(k.label, !0) ? k.label : {};\n            k = c.getBBox ? c.getBBox().height : 0;\n            c.textStr && !g(c.textPxLength) && (c.textPxLength = c.getBBox().width);\n            var n = g(c.textPxLength) ? Math.round(c.textPxLength) : 0;\n            c.textStr && (n = Math.round(c.getBBox().width));\n            a.height = Math.max(k, a.height);\n            a.width = Math.max(n, a.width);\n          }\n        });\n        \"treegrid\" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode && (a.width += this.options.labels.indentation * ((this.treeGrid.mapOfPosToGridNode[-1].height || 0) - 1));\n        return a;\n      }\n\n      function F() {\n        var f = this.grid;\n        (f && f.columns || []).forEach(function (f) {\n          f.getOffset();\n        });\n      }\n\n      function G(f) {\n        if (!0 === (this.options.grid || {}).enabled) {\n          var k = this.axisTitle,\n              c = this.height,\n              n = this.horiz,\n              q = this.left,\n              e = this.offset,\n              N = this.opposite,\n              w = this.options,\n              y = this.top,\n              d = this.width,\n              r = this.tickSize(),\n              g = k && k.getBBox().width,\n              m = w.title.x,\n              z = w.title.y,\n              L = D(w.title.margin, n ? 5 : 10);\n          k = this.chart.renderer.fontMetrics(w.title.style.fontSize, k).f;\n          r = (n ? y + c : q) + (n ? 1 : -1) * (N ? -1 : 1) * (r ? r[0] / 2 : 0) + (this.side === a.Side.bottom ? k : 0);\n          f.titlePosition.x = n ? q - (g || 0) / 2 - L + m : r + (N ? d : 0) + e + m;\n          f.titlePosition.y = n ? r - (N ? c : 0) + (N ? k : -k) / 2 + e + z : y - L + z;\n        }\n      }\n\n      function m() {\n        var f = this.chart,\n            k = this.options.grid;\n        k = void 0 === k ? {} : k;\n        var a = this.userOptions;\n\n        if (k.enabled) {\n          var c = this.options;\n          c.labels.align = D(c.labels.align, \"center\");\n          this.categories || (c.showLastLabel = !1);\n          this.labelRotation = 0;\n          c.labels.rotation = 0;\n        }\n\n        if (k.columns) {\n          c = this.grid.columns = [];\n\n          for (var n = this.grid.columnIndex = 0; ++n < k.columns.length;) {\n            var q = A(a, k.columns[k.columns.length - n - 1], {\n              linkedTo: 0,\n              type: \"category\",\n              scrollbar: {\n                enabled: !1\n              }\n            });\n            delete q.grid.columns;\n            q = new b(this.chart, q);\n            q.grid.isColumn = !0;\n            q.grid.columnIndex = n;\n            x(f.axes, q);\n            x(f[this.coll], q);\n            c.push(q);\n          }\n        }\n      }\n\n      function C() {\n        var f = this.grid,\n            k = this.options;\n\n        if (!0 === (k.grid || {}).enabled) {\n          var c = this.min || 0,\n              n = this.max || 0;\n          this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions);\n          this.rightWall && this.rightWall.destroy();\n\n          if (this.grid && this.grid.isOuterAxis() && this.axisLine) {\n            var q = k.lineWidth;\n\n            if (q) {\n              q = this.getLinePath(q);\n              var e = q[0],\n                  w = q[1],\n                  y = ((this.tickSize(\"tick\") || [1])[0] - 1) * (this.side === a.Side.top || this.side === a.Side.left ? -1 : 1);\n              \"M\" === e[0] && \"L\" === w[0] && (this.horiz ? (e[2] += y, w[2] += y) : (e[1] += y, w[1] += y));\n              !this.horiz && this.chart.marginRight && (e = [e, [\"L\", this.left, e[2] || 0]], y = [\"L\", this.chart.chartWidth - this.chart.marginRight, this.toPixels(n + this.tickmarkOffset)], w = [[\"M\", w[1] || 0, this.toPixels(n + this.tickmarkOffset)], y], this.grid.upperBorder || 0 === c % 1 || (this.grid.upperBorder = this.grid.renderBorder(e)), this.grid.upperBorder && (this.grid.upperBorder.attr({\n                stroke: k.lineColor,\n                \"stroke-width\": k.lineWidth\n              }), this.grid.upperBorder.animate({\n                d: e\n              })), this.grid.lowerBorder || 0 === n % 1 || (this.grid.lowerBorder = this.grid.renderBorder(w)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({\n                stroke: k.lineColor,\n                \"stroke-width\": k.lineWidth\n              }), this.grid.lowerBorder.animate({\n                d: w\n              })));\n              this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({\n                stroke: k.lineColor,\n                \"stroke-width\": k.lineWidth\n              }), this.grid.axisLineExtra.animate({\n                d: q\n              })) : this.grid.axisLineExtra = this.grid.renderBorder(q);\n              this.axisLine[this.showAxis ? \"show\" : \"hide\"](!0);\n            }\n          }\n\n          (f && f.columns || []).forEach(function (f) {\n            f.render();\n          });\n\n          if (!this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar)) {\n            f = this.tickmarkOffset;\n            k = this.tickPositions[this.tickPositions.length - 1];\n            q = this.tickPositions[0];\n\n            for (w = void 0; (w = this.hiddenLabels.pop()) && w.element;) {\n              w.show();\n            }\n\n            (w = this.ticks[q].label) && (c - q > f ? this.hiddenLabels.push(w.hide()) : w.show());\n            (w = this.ticks[k].label) && (k - n > f ? this.hiddenLabels.push(w.hide()) : w.show());\n            (c = this.ticks[k].mark) && (k - n < f && 0 < k - n && this.ticks[k].isLast ? c.hide() : this.ticks[k - 1] && c.show());\n          }\n        }\n      }\n\n      function Q() {\n        var f = this.tickPositions && this.tickPositions.info,\n            k = this.options,\n            a = this.userOptions.labels || {};\n        (k.grid || {}).enabled && (this.horiz ? (this.series.forEach(function (f) {\n          f.options.pointRange = 0;\n        }), f && k.dateTimeLabelFormats && k.labels && !h(a.align) && (!1 === k.dateTimeLabelFormats[f.unitName].range || 1 < f.count) && (k.labels.align = \"left\", h(a.x) || (k.labels.x = 3))) : \"treegrid\" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));\n      }\n\n      function M(f) {\n        var k = this.options;\n        f = f.userOptions;\n        var a = k && u.isObject(k.grid, !0) ? k.grid : {};\n\n        if (!0 === a.enabled) {\n          var c = A(!0, {\n            className: \"highcharts-grid-axis \" + (f.className || \"\"),\n            dateTimeLabelFormats: {\n              hour: {\n                list: [\"%H:%M\", \"%H\"]\n              },\n              day: {\n                list: [\"%A, %e. %B\", \"%a, %e. %b\", \"%E\"]\n              },\n              week: {\n                list: [\"Week %W\", \"W%W\"]\n              },\n              month: {\n                list: [\"%B\", \"%b\", \"%o\"]\n              }\n            },\n            grid: {\n              borderWidth: 1\n            },\n            labels: {\n              padding: 2,\n              style: {\n                fontSize: \"13px\"\n              }\n            },\n            margin: 0,\n            title: {\n              text: null,\n              reserveSpace: !1,\n              rotation: 0\n            },\n            units: [[\"millisecond\", [1, 10, 100]], [\"second\", [1, 10]], [\"minute\", [1, 5, 15]], [\"hour\", [1, 6]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1]], [\"year\", null]]\n          }, f);\n          \"xAxis\" === this.coll && (h(f.linkedTo) && !h(f.tickPixelInterval) && (c.tickPixelInterval = 350), h(f.tickPixelInterval) || !h(f.linkedTo) || h(f.tickPositioner) || h(f.tickInterval) || (c.tickPositioner = function (f, k) {\n            var a = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;\n\n            if (a) {\n              for (var n = c.units || [], q = void 0, w = void 0, e = void 0, y = 0; y < n.length; y++) {\n                if (n[y][0] === a.unitName) {\n                  q = y;\n                  break;\n                }\n              }\n\n              n[q + 1] ? (e = n[q + 1][0], w = (n[q + 1][1] || [1])[0]) : \"year\" === a.unitName && (e = \"year\", w = 10 * a.count);\n              a = H[e];\n              this.tickInterval = a * w;\n              return this.getTimeTicks({\n                unitRange: a,\n                count: w,\n                unitName: e\n              }, f, k, this.options.startOfWeek);\n            }\n          }));\n          A(!0, this.options, c);\n          this.horiz && (k.minPadding = D(f.minPadding, 0), k.maxPadding = D(f.maxPadding, 0));\n          g(k.grid.borderWidth) && (k.tickWidth = k.lineWidth = a.borderWidth);\n        }\n      }\n\n      function E(f) {\n        f = (f = f.userOptions) && f.grid || {};\n        var k = f.columns;\n        f.enabled && k && A(!0, this.options, k[k.length - 1]);\n      }\n\n      function K() {\n        (this.grid.columns || []).forEach(function (f) {\n          f.setScale();\n        });\n      }\n\n      function I(f) {\n        var k = t.defaultLeftAxisOptions,\n            a = this.horiz,\n            c = this.maxLabelDimensions,\n            n = this.options.grid;\n        n = void 0 === n ? {} : n;\n        n.enabled && c && (k = 2 * Math.abs(k.labels.x), a = a ? n.cellHeight || k + c.height : k + c.width, p(f.tickSize) ? f.tickSize[0] = a : f.tickSize = [a, 0]);\n      }\n\n      function z() {\n        this.axes.forEach(function (f) {\n          (f.grid && f.grid.columns || []).forEach(function (f) {\n            f.setAxisSize();\n            f.setAxisTranslation();\n          });\n        });\n      }\n\n      function n(f) {\n        var k = this.grid;\n        (k.columns || []).forEach(function (k) {\n          k.destroy(f.keepEvents);\n        });\n        k.columns = void 0;\n      }\n\n      function y(f) {\n        f = f.userOptions || {};\n        var k = f.grid || {};\n        k.enabled && h(k.borderColor) && (f.tickColor = f.lineColor = k.borderColor);\n        this.grid || (this.grid = new L(this));\n        this.hiddenLabels = [];\n      }\n\n      function q(f) {\n        var k = this.label,\n            c = this.axis,\n            n = c.reversed,\n            q = c.chart,\n            w = c.options.grid || {},\n            e = c.options.labels,\n            y = e.align,\n            d = a.Side[c.side],\n            r = f.tickmarkOffset,\n            m = c.tickPositions,\n            N = this.pos - r;\n        m = g(m[f.index + 1]) ? m[f.index + 1] - r : (c.max || 0) + r;\n        var z = c.tickSize(\"tick\");\n        r = z ? z[0] : 0;\n        z = z ? z[1] / 2 : 0;\n\n        if (!0 === w.enabled) {\n          if (\"top\" === d) {\n            w = c.top + c.offset;\n            var L = w - r;\n          } else \"bottom\" === d ? (L = q.chartHeight - c.bottom + c.offset, w = L + r) : (w = c.top + c.len - (c.translate(n ? m : N) || 0), L = c.top + c.len - (c.translate(n ? N : m) || 0));\n\n          \"right\" === d ? (d = q.chartWidth - c.right + c.offset, n = d + r) : \"left\" === d ? (n = c.left + c.offset, d = n - r) : (d = Math.round(c.left + (c.translate(n ? m : N) || 0)) - z, n = Math.min(Math.round(c.left + (c.translate(n ? N : m) || 0)) - z, c.left + c.len));\n          this.slotWidth = n - d;\n          f.pos.x = \"left\" === y ? d : \"right\" === y ? n : d + (n - d) / 2;\n          f.pos.y = L + (w - L) / 2;\n          q = q.renderer.fontMetrics(e.style.fontSize, k && k.element);\n          k = k ? k.getBBox().height : 0;\n          e.useHTML ? f.pos.y += q.b + -(k / 2) : (k = Math.round(k / q.h), f.pos.y += (q.b - (q.h - q.f)) / 2 + -((k - 1) * q.h / 2));\n          f.pos.x += c.horiz && e.x || 0;\n        }\n      }\n\n      function f(f) {\n        var k = f.axis,\n            a = f.value;\n\n        if (k.options.grid && k.options.grid.enabled) {\n          var c = k.tickPositions,\n              n = (k.linkedParent || k).series[0],\n              q = a === c[0];\n          c = a === c[c.length - 1];\n          var w = n && d(n.options.data, function (f) {\n            return f[k.isXAxis ? \"x\" : \"y\"] === a;\n          }),\n              e = void 0;\n          w && n.is(\"gantt\") && (e = A(w), v.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(e));\n          f.isFirst = q;\n          f.isLast = c;\n          f.point = e;\n        }\n      }\n\n      function k() {\n        var f = this.options,\n            k = this.categories,\n            a = this.tickPositions,\n            c = a[0],\n            n = a[a.length - 1],\n            q = this.linkedParent && this.linkedParent.min || this.min,\n            w = this.linkedParent && this.linkedParent.max || this.max,\n            e = this.tickInterval;\n        !0 !== (f.grid || {}).enabled || k || !this.horiz && !this.isLinked || (c < q && c + e > q && !f.startOnTick && (a[0] = q), n > w && n - e < w && !f.endOnTick && (a[a.length - 1] = w));\n      }\n\n      function w(f) {\n        var k = this.options.grid;\n        return !0 === (void 0 === k ? {} : k).enabled && this.categories ? this.tickInterval : f.apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n\n      (function (f) {\n        f[f.top = 0] = \"top\";\n        f[f.right = 1] = \"right\";\n        f[f.bottom = 2] = \"bottom\";\n        f[f.left = 3] = \"left\";\n      })(a.Side || (a.Side = {}));\n\n      a.compose = function (a, d, r) {\n        -1 === a.keepProps.indexOf(\"grid\") && (a.keepProps.push(\"grid\"), a.prototype.getMaxLabelDimensions = c, e(a.prototype, \"unsquish\", w), l(a, \"init\", y), l(a, \"afterGetOffset\", F), l(a, \"afterGetTitlePosition\", G), l(a, \"afterInit\", m), l(a, \"afterRender\", C), l(a, \"afterSetAxisTranslation\", Q), l(a, \"afterSetOptions\", M), l(a, \"afterSetOptions\", E), l(a, \"afterSetScale\", K), l(a, \"afterTickSize\", I), l(a, \"trimTicks\", k), l(a, \"destroy\", n));\n        l(d, \"afterSetChartSize\", z);\n        l(r, \"afterGetLabelPosition\", q);\n        l(r, \"labelFormat\", f);\n        return a;\n      };\n\n      var L = function () {\n        function f(f) {\n          this.axis = f;\n        }\n\n        f.prototype.isOuterAxis = function () {\n          var f = this.axis,\n              k = f.grid.columnIndex,\n              a = f.linkedParent && f.linkedParent.grid.columns || f.grid.columns,\n              c = k ? f.linkedParent : f,\n              n = -1,\n              q = 0;\n          f.chart[f.coll].forEach(function (k, a) {\n            k.side !== f.side || k.options.isInternal || (q = a, k === c && (n = a));\n          });\n          return q === n && (g(k) ? a.length === k : !0);\n        };\n\n        f.prototype.renderBorder = function (f) {\n          var k = this.axis,\n              a = k.chart.renderer,\n              c = k.options;\n          f = a.path(f).addClass(\"highcharts-axis-line\").add(k.axisBorder);\n          a.styledMode || f.attr({\n            stroke: c.lineColor,\n            \"stroke-width\": c.lineWidth,\n            zIndex: 7\n          });\n          return f;\n        };\n\n        return f;\n      }();\n\n      a.Additions = L;\n    })(a || (a = {}));\n\n    B.E = function (a) {\n      return this.dateFormat(\"%a\", a, !0).charAt(0);\n    };\n\n    B.W = function (a) {\n      a = new this.Date(a);\n      var c = (this.get(\"Day\", a) + 6) % 7,\n          e = new this.Date(a.valueOf());\n      this.set(\"Date\", e, this.get(\"Date\", a) - c + 3);\n      c = new this.Date(this.get(\"FullYear\", e), 0, 1);\n      4 !== this.get(\"Day\", c) && (this.set(\"Month\", a, 0), this.set(\"Date\", a, 1 + (11 - this.get(\"Day\", c)) % 7));\n      return (1 + Math.floor((e.valueOf() - c.valueOf()) / 6048E5)).toString();\n    };\n\n    \"\";\n    return a;\n  });\n  J(b, \"Gantt/Tree.js\", [b[\"Core/Utilities.js\"]], function (b) {\n    var t = b.extend,\n        v = b.isNumber,\n        u = b.pick,\n        B = function B(h, b) {\n      var d = h.reduce(function (d, g) {\n        var p = u(g.parent, \"\");\n        \"undefined\" === typeof d[p] && (d[p] = []);\n        d[p].push(g);\n        return d;\n      }, {});\n      Object.keys(d).forEach(function (p, g) {\n        var h = d[p];\n        \"\" !== p && -1 === b.indexOf(p) && (h.forEach(function (d) {\n          g[\"\"].push(d);\n        }), delete g[p]);\n      });\n      return d;\n    },\n        l = function l(h, b, d, p, g, A) {\n      var D = 0,\n          H = 0,\n          e = A && A.after,\n          a = A && A.before;\n      b = {\n        data: p,\n        depth: d - 1,\n        id: h,\n        level: d,\n        parent: b\n      };\n      var c, r;\n      \"function\" === typeof a && a(b, A);\n      a = (g[h] || []).map(function (a) {\n        var e = l(a.id, h, d + 1, a, g, A),\n            m = a.start;\n        a = !0 === a.milestone ? m : a.end;\n        c = !v(c) || m < c ? m : c;\n        r = !v(r) || a > r ? a : r;\n        D = D + 1 + e.descendants;\n        H = Math.max(e.height + 1, H);\n        return e;\n      });\n      p && (p.start = u(p.start, c), p.end = u(p.end, r));\n      t(b, {\n        children: a,\n        descendants: D,\n        height: H\n      });\n      \"function\" === typeof e && e(b, A);\n      return b;\n    };\n\n    return {\n      getListOfParents: B,\n      getNode: l,\n      getTree: function getTree(h, b) {\n        var d = h.map(function (d) {\n          return d.id;\n        });\n        h = B(h, d);\n        return l(\"\", null, 1, null, h, b);\n      }\n    };\n  });\n  J(b, \"Core/Axis/TreeGridTick.js\", [b[\"Core/Utilities.js\"]], function (b) {\n    var t = b.addEvent,\n        v = b.isObject,\n        u = b.isNumber,\n        B = b.pick,\n        l = b.wrap,\n        h;\n\n    (function (b) {\n      function d() {\n        this.treeGrid || (this.treeGrid = new H(this));\n      }\n\n      function p(e, a) {\n        e = e.treeGrid;\n        var c = !e.labelIcon,\n            d = a.renderer,\n            g = a.xy,\n            b = a.options,\n            m = b.width || 0,\n            p = b.height || 0,\n            h = g.x - m / 2 - (b.padding || 0);\n        g = g.y - p / 2;\n        var l = a.collapsed ? 90 : 180,\n            A = a.show && u(g),\n            D = e.labelIcon;\n        D || (e.labelIcon = D = d.path(d.symbols[b.type](b.x || 0, b.y || 0, m, p)).addClass(\"highcharts-label-icon\").add(a.group));\n        D.attr({\n          y: A ? 0 : -9999\n        });\n        d.styledMode || D.attr({\n          cursor: \"pointer\",\n          fill: B(a.color, \"#666666\"),\n          \"stroke-width\": 1,\n          stroke: b.lineColor,\n          strokeWidth: b.lineWidth || 0\n        });\n        D[c ? \"attr\" : \"animate\"]({\n          translateX: h,\n          translateY: g,\n          rotation: l\n        });\n      }\n\n      function g(e, a, c, d, g, b, m, p, h) {\n        var r = B(this.options && this.options.labels, b);\n        b = this.pos;\n        var C = this.axis,\n            F = \"treegrid\" === C.options.type;\n        e = e.apply(this, [a, c, d, g, r, m, p, h]);\n        F && (a = r && v(r.symbol, !0) ? r.symbol : {}, r = r && u(r.indentation) ? r.indentation : 0, b = (b = (C = C.treeGrid.mapOfPosToGridNode) && C[b]) && b.depth || 1, e.x += (a.width || 0) + 2 * (a.padding || 0) + (b - 1) * r);\n        return e;\n      }\n\n      function h(e) {\n        var a = this,\n            c = a.pos,\n            d = a.axis,\n            g = a.label,\n            b = d.treeGrid.mapOfPosToGridNode,\n            m = d.options,\n            h = B(a.options && a.options.labels, m && m.labels),\n            l = h && v(h.symbol, !0) ? h.symbol : {},\n            A = (b = b && b[c]) && b.depth;\n        m = \"treegrid\" === m.type;\n        var D = -1 < d.tickPositions.indexOf(c);\n        c = d.chart.styledMode;\n        m && b && g && g.element && g.addClass(\"highcharts-treegrid-node-level-\" + A);\n        e.apply(a, Array.prototype.slice.call(arguments, 1));\n        m && g && g.element && b && b.descendants && 0 < b.descendants && (d = d.treeGrid.isCollapsed(b), p(a, {\n          color: !c && g.styles && g.styles.color || \"\",\n          collapsed: d,\n          group: g.parentGroup,\n          options: l,\n          renderer: g.renderer,\n          show: D,\n          xy: g.xy\n        }), l = \"highcharts-treegrid-node-\" + (d ? \"expanded\" : \"collapsed\"), g.addClass(\"highcharts-treegrid-node-\" + (d ? \"collapsed\" : \"expanded\")).removeClass(l), c || g.css({\n          cursor: \"pointer\"\n        }), [g, a.treeGrid.labelIcon].forEach(function (c) {\n          c && !c.attachedTreeGridEvents && (t(c.element, \"mouseover\", function () {\n            g.addClass(\"highcharts-treegrid-node-active\");\n            g.renderer.styledMode || g.css({\n              textDecoration: \"underline\"\n            });\n          }), t(c.element, \"mouseout\", function () {\n            var a = v(h.style) ? h.style : {};\n            g.removeClass(\"highcharts-treegrid-node-active\");\n            g.renderer.styledMode || g.css({\n              textDecoration: a.textDecoration\n            });\n          }), t(c.element, \"click\", function () {\n            a.treeGrid.toggleCollapse();\n          }), c.attachedTreeGridEvents = !0);\n        }));\n      }\n\n      var D = !1;\n\n      b.compose = function (e) {\n        D || (t(e, \"init\", d), l(e.prototype, \"getLabelPosition\", g), l(e.prototype, \"renderLabel\", h), e.prototype.collapse = function (a) {\n          this.treeGrid.collapse(a);\n        }, e.prototype.expand = function (a) {\n          this.treeGrid.expand(a);\n        }, e.prototype.toggleCollapse = function (a) {\n          this.treeGrid.toggleCollapse(a);\n        }, D = !0);\n      };\n\n      var H = function () {\n        function e(a) {\n          this.tick = a;\n        }\n\n        e.prototype.collapse = function (a) {\n          var c = this.tick,\n              e = c.axis,\n              d = e.brokenAxis;\n          d && e.treeGrid.mapOfPosToGridNode && (c = e.treeGrid.collapse(e.treeGrid.mapOfPosToGridNode[c.pos]), d.setBreaks(c, B(a, !0)));\n        };\n\n        e.prototype.expand = function (a) {\n          var c = this.tick,\n              e = c.axis,\n              d = e.brokenAxis;\n          d && e.treeGrid.mapOfPosToGridNode && (c = e.treeGrid.expand(e.treeGrid.mapOfPosToGridNode[c.pos]), d.setBreaks(c, B(a, !0)));\n        };\n\n        e.prototype.toggleCollapse = function (a) {\n          var c = this.tick,\n              e = c.axis,\n              d = e.brokenAxis;\n          d && e.treeGrid.mapOfPosToGridNode && (c = e.treeGrid.toggleCollapse(e.treeGrid.mapOfPosToGridNode[c.pos]), d.setBreaks(c, B(a, !0)));\n        };\n\n        return e;\n      }();\n\n      b.Additions = H;\n    })(h || (h = {}));\n\n    return h;\n  });\n  J(b, \"Series/TreeUtilities.js\", [b[\"Core/Color/Color.js\"], b[\"Core/Utilities.js\"]], function (b, t) {\n    function v(b, g) {\n      var h = g.before,\n          p = g.idRoot,\n          l = g.mapIdToNode[p],\n          e = g.points[b.i],\n          a = e && e.options || {},\n          c = [],\n          r = 0;\n      b.levelDynamic = b.level - (!1 !== g.levelIsConstant ? 0 : l.level);\n      b.name = d(e && e.name, \"\");\n      b.visible = p === b.id || !0 === g.visible;\n      \"function\" === typeof h && (b = h(b, g));\n      b.children.forEach(function (a, e) {\n        var d = u({}, g);\n        u(d, {\n          index: e,\n          siblings: b.children.length,\n          visible: b.visible\n        });\n        a = v(a, d);\n        c.push(a);\n        a.visible && (r += a.val);\n      });\n      h = d(a.value, r);\n      b.visible = 0 <= h && (0 < r || b.visible);\n      b.children = c;\n      b.childrenTotal = r;\n      b.isLeaf = b.visible && !r;\n      b.val = h;\n      return b;\n    }\n\n    var u = t.extend,\n        B = t.isArray,\n        l = t.isNumber,\n        h = t.isObject,\n        x = t.merge,\n        d = t.pick;\n    return {\n      getColor: function getColor(h, g) {\n        var l = g.index,\n            p = g.mapOptionsToLevel,\n            H = g.parentColor,\n            e = g.parentColorIndex,\n            a = g.series,\n            c = g.colors,\n            r = g.siblings,\n            F = a.points,\n            G = a.chart.options.chart,\n            m;\n\n        if (h) {\n          F = F[h.i];\n          h = p[h.level] || {};\n\n          if (p = F && h.colorByPoint) {\n            var C = F.index % (c ? c.length : G.colorCount);\n            var x = c && c[C];\n          }\n\n          if (!a.chart.styledMode) {\n            c = F && F.options.color;\n            G = h && h.color;\n            if (m = H) m = (m = h && h.colorVariation) && \"brightness\" === m.key && l && r ? b.parse(H).brighten(l / r * m.to).get() : H;\n            m = d(c, G, x, m, a.color);\n          }\n\n          var t = d(F && F.options.colorIndex, h && h.colorIndex, C, e, g.colorIndex);\n        }\n\n        return {\n          color: m,\n          colorIndex: t\n        };\n      },\n      getLevelOptions: function getLevelOptions(b) {\n        var g = null;\n\n        if (h(b)) {\n          g = {};\n          var A = l(b.from) ? b.from : 1;\n          var p = b.levels;\n          var H = {};\n          var e = h(b.defaults) ? b.defaults : {};\n          B(p) && (H = p.reduce(function (a, c) {\n            if (h(c) && l(c.level)) {\n              var g = x({}, c);\n              var b = d(g.levelIsConstant, e.levelIsConstant);\n              delete g.levelIsConstant;\n              delete g.level;\n              c = c.level + (b ? 0 : A - 1);\n              h(a[c]) ? x(!0, a[c], g) : a[c] = g;\n            }\n\n            return a;\n          }, {}));\n          p = l(b.to) ? b.to : 1;\n\n          for (b = 0; b <= p; b++) {\n            g[b] = x({}, e, h(H[b]) ? H[b] : {});\n          }\n        }\n\n        return g;\n      },\n      setTreeValues: v,\n      updateRootId: function updateRootId(b) {\n        if (h(b)) {\n          var g = h(b.options) ? b.options : {};\n          g = d(b.rootNode, g.rootId, \"\");\n          h(b.userOptions) && (b.userOptions.rootId = g);\n          b.rootNode = g;\n        }\n\n        return g;\n      }\n    };\n  });\n  J(b, \"Core/Axis/TreeGridAxis.js\", [b[\"Core/Axis/BrokenAxis.js\"], b[\"Core/Axis/GridAxis.js\"], b[\"Gantt/Tree.js\"], b[\"Core/Axis/TreeGridTick.js\"], b[\"Series/TreeUtilities.js\"], b[\"Core/Utilities.js\"]], function (b, t, v, u, B, l) {\n    var h = B.getLevelOptions,\n        x = l.addEvent,\n        d = l.find,\n        p = l.fireEvent,\n        g = l.isArray,\n        A = l.isObject,\n        D = l.isString,\n        H = l.merge,\n        e = l.pick,\n        a = l.wrap,\n        c;\n\n    (function (c) {\n      function r(a, c) {\n        var n = a.collapseEnd || 0;\n        a = a.collapseStart || 0;\n        n >= c && (a -= .5);\n        return {\n          from: a,\n          to: n,\n          showPoints: !1\n        };\n      }\n\n      function l(a, c, n) {\n        var e = [],\n            q = [],\n            f = {},\n            k = \"boolean\" === typeof c ? c : !1,\n            w = {},\n            g = -1;\n        a = v.getTree(a, {\n          after: function after(f) {\n            f = w[f.pos];\n            var k = 0,\n                a = 0;\n            f.children.forEach(function (f) {\n              a += (f.descendants || 0) + 1;\n              k = Math.max((f.height || 0) + 1, k);\n            });\n            f.descendants = a;\n            f.height = k;\n            f.collapsed && q.push(f);\n          },\n          before: function before(a) {\n            var c = A(a.data, !0) ? a.data : {},\n                n = D(c.name) ? c.name : \"\",\n                q = f[a.parent];\n            q = A(q, !0) ? w[q.pos] : null;\n\n            var y = function y(f) {\n              return f.name === n;\n            },\n                b;\n\n            k && A(q, !0) && (b = d(q.children, y)) ? (y = b.pos, b.nodes.push(a)) : y = g++;\n            w[y] || (w[y] = b = {\n              depth: q ? q.depth + 1 : 0,\n              name: n,\n              id: c.id,\n              nodes: [a],\n              children: [],\n              pos: y\n            }, -1 !== y && e.push(n), A(q, !0) && q.children.push(b));\n            D(a.id) && (f[a.id] = a);\n            b && !0 === c.collapsed && (b.collapsed = !0);\n            a.pos = y;\n          }\n        });\n\n        w = function (f, k) {\n          var a = function a(f, c, n) {\n            var q = c + (-1 === c ? 0 : k - 1),\n                e = (q - c) / 2,\n                w = c + e;\n            f.nodes.forEach(function (f) {\n              var k = f.data;\n              A(k, !0) && (k.y = c + (k.seriesIndex || 0), delete k.seriesIndex);\n              f.pos = w;\n            });\n            n[w] = f;\n            f.pos = w;\n            f.tickmarkOffset = e + .5;\n            f.collapseStart = q + .5;\n            f.children.forEach(function (f) {\n              a(f, q + 1, n);\n              q = (f.collapseEnd || 0) - .5;\n            });\n            f.collapseEnd = q + .5;\n            return n;\n          };\n\n          return a(f[\"-1\"], -1, {});\n        }(w, n);\n\n        return {\n          categories: e,\n          mapOfIdToNode: f,\n          mapOfPosToGridNode: w,\n          collapsedNodes: q,\n          tree: a\n        };\n      }\n\n      function m(a) {\n        a.target.axes.filter(function (a) {\n          return \"treegrid\" === a.options.type;\n        }).forEach(function (c) {\n          var n = c.options || {},\n              e = n.labels,\n              q = n.uniqueNames;\n          n = n.max;\n          var f = 0;\n\n          if (!c.treeGrid.mapOfPosToGridNode || c.series.some(function (f) {\n            return !f.hasRendered || f.isDirtyData || f.isDirty;\n          })) {\n            var k = c.series.reduce(function (k, a) {\n              a.visible && ((a.options.data || []).forEach(function (c) {\n                a.options.keys && a.options.keys.length && (c = a.pointClass.prototype.optionsToObject.call({\n                  series: a\n                }, c), a.pointClass.setGanttPointAliases(c));\n                A(c, !0) && (c.seriesIndex = f, k.push(c));\n              }), !0 === q && f++);\n              return k;\n            }, []);\n            if (n && k.length < n) for (var w = k.length; w <= n; w++) {\n              k.push({\n                name: w + \"\\u200B\"\n              });\n            }\n            n = l(k, q || !1, !0 === q ? f : 1);\n            c.categories = n.categories;\n            c.treeGrid.mapOfPosToGridNode = n.mapOfPosToGridNode;\n            c.hasNames = !0;\n            c.treeGrid.tree = n.tree;\n            c.series.forEach(function (f) {\n              var a = (f.options.data || []).map(function (a) {\n                g(a) && f.options.keys && f.options.keys.length && k.forEach(function (f) {\n                  0 <= a.indexOf(f.x) && 0 <= a.indexOf(f.x2) && (a = f);\n                });\n                return A(a, !0) ? H(a) : a;\n              });\n              f.visible && f.setData(a, !1);\n            });\n            c.treeGrid.mapOptionsToLevel = h({\n              defaults: e,\n              from: 1,\n              levels: e && e.levels,\n              to: c.treeGrid.tree && c.treeGrid.tree.height\n            });\n            \"beforeRender\" === a.type && (c.treeGrid.collapsedNodes = n.collapsedNodes);\n          }\n        });\n      }\n\n      function C(a, c) {\n        var n = this.treeGrid.mapOptionsToLevel || {},\n            e = this.ticks,\n            q = e[c],\n            f;\n\n        if (\"treegrid\" === this.options.type && this.treeGrid.mapOfPosToGridNode) {\n          var k = this.treeGrid.mapOfPosToGridNode[c];\n          (n = n[k.depth]) && (f = {\n            labels: n\n          });\n          !q && E ? e[c] = new E(this, c, void 0, void 0, {\n            category: k.name,\n            tickmarkOffset: k.tickmarkOffset,\n            options: f\n          }) : (q.parameters.category = k.name, q.options = f, q.addLabel());\n        } else a.apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n\n      function Q(a, c, n) {\n        var e = this,\n            q = \"treegrid\" === n.type;\n        e.treeGrid || (e.treeGrid = new K(e));\n        q && (x(c, \"beforeRender\", m), x(c, \"beforeRedraw\", m), x(c, \"addSeries\", function (f) {\n          f.options.data && (f = l(f.options.data, n.uniqueNames || !1, 1), e.treeGrid.collapsedNodes = (e.treeGrid.collapsedNodes || []).concat(f.collapsedNodes));\n        }), x(e, \"foundExtremes\", function () {\n          e.treeGrid.collapsedNodes && e.treeGrid.collapsedNodes.forEach(function (f) {\n            var k = e.treeGrid.collapse(f);\n            e.brokenAxis && (e.brokenAxis.setBreaks(k, !1), e.treeGrid.collapsedNodes && (e.treeGrid.collapsedNodes = e.treeGrid.collapsedNodes.filter(function (k) {\n              return f.collapseStart !== k.collapseStart || f.collapseEnd !== k.collapseEnd;\n            })));\n          });\n        }), x(e, \"afterBreaks\", function () {\n          \"yAxis\" === e.coll && !e.staticScale && e.chart.options.chart.height && (e.isDirty = !0);\n        }), n = H({\n          grid: {\n            enabled: !0\n          },\n          labels: {\n            align: \"left\",\n            levels: [{\n              level: void 0\n            }, {\n              level: 1,\n              style: {\n                fontWeight: \"bold\"\n              }\n            }],\n            symbol: {\n              type: \"triangle\",\n              x: -5,\n              y: -5,\n              height: 10,\n              width: 10,\n              padding: 5\n            }\n          },\n          uniqueNames: !1\n        }, n, {\n          reversed: !0,\n          grid: {\n            columns: void 0\n          }\n        }));\n        a.apply(e, [c, n]);\n        q && (e.hasNames = !0, e.options.showLastLabel = !0);\n      }\n\n      function B(a) {\n        var c = this.options;\n        \"treegrid\" === c.type ? (this.min = e(this.userMin, c.min, this.dataMin), this.max = e(this.userMax, c.max, this.dataMax), p(this, \"foundExtremes\"), this.setAxisTranslation(), this.tickmarkOffset = .5, this.tickInterval = 1, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : []) : a.apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n\n      var E;\n\n      c.compose = function (c, e, n, d) {\n        -1 === c.keepProps.indexOf(\"treeGrid\") && (c.keepProps.push(\"treeGrid\"), E = d, a(c.prototype, \"generateTick\", C), a(c.prototype, \"init\", Q), a(c.prototype, \"setTickInterval\", B), c.prototype.utils = {\n          getNode: v.getNode\n        }, t.compose(c, e, d), b.compose(c, n), u.compose(d));\n        return c;\n      };\n\n      var K = function () {\n        function a(a) {\n          this.axis = a;\n        }\n\n        a.prototype.setCollapsedStatus = function (a) {\n          var c = this.axis,\n              e = c.chart;\n          c.series.forEach(function (c) {\n            var f = c.options.data;\n\n            if (a.id && f) {\n              var k = e.get(a.id);\n              c = f[c.data.indexOf(k)];\n              k && c && (k.collapsed = a.collapsed, c.collapsed = a.collapsed);\n            }\n          });\n        };\n\n        a.prototype.collapse = function (a) {\n          var c = this.axis,\n              e = c.options.breaks || [],\n              q = r(a, c.max);\n          e.push(q);\n          a.collapsed = !0;\n          c.treeGrid.setCollapsedStatus(a);\n          return e;\n        };\n\n        a.prototype.expand = function (a) {\n          var c = this.axis,\n              e = c.options.breaks || [],\n              q = r(a, c.max);\n          a.collapsed = !1;\n          c.treeGrid.setCollapsedStatus(a);\n          return e.reduce(function (f, a) {\n            a.to === q.to && a.from === q.from || f.push(a);\n            return f;\n          }, []);\n        };\n\n        a.prototype.getTickPositions = function () {\n          var a = this.axis,\n              c = Math.floor(a.min / a.tickInterval) * a.tickInterval,\n              e = Math.ceil(a.max / a.tickInterval) * a.tickInterval;\n          return Object.keys(a.treeGrid.mapOfPosToGridNode || {}).reduce(function (n, f) {\n            f = +f;\n            !(f >= c && f <= e) || a.brokenAxis && a.brokenAxis.isInAnyBreak(f) || n.push(f);\n            return n;\n          }, []);\n        };\n\n        a.prototype.isCollapsed = function (a) {\n          var c = this.axis,\n              e = c.options.breaks || [],\n              q = r(a, c.max);\n          return e.some(function (f) {\n            return f.from === q.from && f.to === q.to;\n          });\n        };\n\n        a.prototype.toggleCollapse = function (a) {\n          return this.isCollapsed(a) ? this.expand(a) : this.collapse(a);\n        };\n\n        return a;\n      }();\n\n      c.Additions = K;\n    })(c || (c = {}));\n\n    return c;\n  });\n  J(b, \"Extensions/CurrentDateIndication.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], b[\"Core/Utilities.js\"]], function (b, t, v) {\n    var u = v.addEvent,\n        B = v.merge;\n    v = v.wrap;\n    var l = {\n      color: \"#ccd6eb\",\n      width: 2,\n      label: {\n        format: \"%a, %b %d %Y, %H:%M\",\n        formatter: function formatter(b, l) {\n          return this.axis.chart.time.dateFormat(l || \"\", b);\n        },\n        rotation: 0,\n        style: {\n          fontSize: \"10px\"\n        }\n      }\n    };\n    u(b, \"afterSetOptions\", function () {\n      var b = this.options,\n          x = b.currentDateIndicator;\n      x && (x = \"object\" === typeof x ? B(l, x) : B(l), x.value = Date.now(), x.className = \"highcharts-current-date-indicator\", b.plotLines || (b.plotLines = []), b.plotLines.push(x));\n    });\n    u(t, \"render\", function () {\n      this.label && this.label.attr({\n        text: this.getLabelText(this.options.label)\n      });\n    });\n    v(t.prototype, \"getLabelText\", function (b, l) {\n      var d = this.options;\n      return d && d.className && -1 !== d.className.indexOf(\"highcharts-current-date-indicator\") && d.label && \"function\" === typeof d.label.formatter ? (d.value = Date.now(), d.label.formatter.call(this, d.value, d.label.format)) : b.call(this, l);\n    });\n  });\n  J(b, \"Extensions/StaticScale.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Chart/Chart.js\"], b[\"Core/Utilities.js\"]], function (b, t, v) {\n    var u = v.addEvent,\n        B = v.defined,\n        l = v.isNumber,\n        h = v.pick;\n    u(b, \"afterSetOptions\", function () {\n      var b = this.chart.options.chart;\n      !this.horiz && l(this.options.staticScale) && (!b.height || b.scrollablePlotArea && b.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);\n    });\n\n    t.prototype.adjustHeight = function () {\n      \"adjustHeight\" !== this.redrawTrigger && ((this.axes || []).forEach(function (b) {\n        var d = b.chart,\n            l = !!d.initiatedScale && d.options.animation,\n            g = b.options.staticScale;\n\n        if (b.staticScale && B(b.min)) {\n          var A = h(b.brokenAxis && b.brokenAxis.unitLength, b.max + b.tickInterval - b.min) * g;\n          A = Math.max(A, g);\n          g = A - d.plotHeight;\n          !d.scrollablePixelsY && 1 <= Math.abs(g) && (d.plotHeight = A, d.redrawTrigger = \"adjustHeight\", d.setSize(void 0, d.chartHeight + g, l));\n          b.series.forEach(function (g) {\n            (g = g.sharedClipKey && d.sharedClips[g.sharedClipKey]) && g.attr(d.inverted ? {\n              width: d.plotHeight\n            } : {\n              height: d.plotHeight\n            });\n          });\n        }\n      }), this.initiatedScale = !0);\n      this.redrawTrigger = null;\n    };\n\n    u(t, \"render\", t.prototype.adjustHeight);\n  });\n  J(b, \"Extensions/ArrowSymbols.js\", [b[\"Core/Renderer/SVG/SVGRenderer.js\"]], function (b) {\n    function t(b, l, h, t) {\n      return [[\"M\", b, l + t / 2], [\"L\", b + h, l], [\"L\", b, l + t / 2], [\"L\", b + h, l + t]];\n    }\n\n    function v(b, l, h, t) {\n      return [[\"M\", b + h, l], [\"L\", b, l + t / 2], [\"L\", b + h, l + t], [\"Z\"]];\n    }\n\n    function u(b, l, h, t) {\n      return v(b, l, h / 2, t);\n    }\n\n    b = b.prototype.symbols;\n    b.arrow = t;\n    b[\"arrow-filled\"] = v;\n    b[\"arrow-filled-half\"] = u;\n\n    b[\"arrow-half\"] = function (b, l, h, u) {\n      return t(b, l, h / 2, u);\n    };\n\n    b[\"triangle-left\"] = v;\n    b[\"triangle-left-half\"] = u;\n    return b;\n  });\n  J(b, \"Gantt/Connection.js\", [b[\"Core/Globals.js\"], b[\"Core/DefaultOptions.js\"], b[\"Core/Series/Point.js\"], b[\"Core/Utilities.js\"]], function (b, t, v, u) {\n    function B(d) {\n      var e = d.shapeArgs;\n      return e ? {\n        xMin: e.x || 0,\n        xMax: (e.x || 0) + (e.width || 0),\n        yMin: e.y || 0,\n        yMax: (e.y || 0) + (e.height || 0)\n      } : (e = d.graphic && d.graphic.getBBox()) ? {\n        xMin: d.plotX - e.width / 2,\n        xMax: d.plotX + e.width / 2,\n        yMin: d.plotY - e.height / 2,\n        yMax: d.plotY + e.height / 2\n      } : null;\n    }\n\n    \"\";\n    var l = u.defined,\n        h = u.error,\n        x = u.extend,\n        d = u.merge,\n        p = u.objectEach,\n        g = b.deg2rad,\n        A = Math.max,\n        D = Math.min;\n    x(t.defaultOptions, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n\n    t = function () {\n      function b(e, a, c) {\n        this.toPoint = this.pathfinder = this.graphics = this.fromPoint = this.chart = void 0;\n        this.init(e, a, c);\n      }\n\n      b.prototype.init = function (e, a, c) {\n        this.fromPoint = e;\n        this.toPoint = a;\n        this.options = c;\n        this.chart = e.series.chart;\n        this.pathfinder = this.chart.pathfinder;\n      };\n\n      b.prototype.renderPath = function (e, a, c) {\n        var d = this.chart,\n            b = d.styledMode,\n            g = d.pathfinder,\n            m = !d.options.chart.forExport && !1 !== c,\n            h = this.graphics && this.graphics.path;\n        g.group || (g.group = d.renderer.g().addClass(\"highcharts-pathfinder-group\").attr({\n          zIndex: -1\n        }).add(d.seriesGroup));\n        g.group.translate(d.plotLeft, d.plotTop);\n        h && h.renderer || (h = d.renderer.path().add(g.group), b || h.attr({\n          opacity: 0\n        }));\n        h.attr(a);\n        e = {\n          d: e\n        };\n        b || (e.opacity = 1);\n        h[m ? \"animate\" : \"attr\"](e, c);\n        this.graphics = this.graphics || {};\n        this.graphics.path = h;\n      };\n\n      b.prototype.addMarker = function (e, a, c) {\n        var d = this.fromPoint.series.chart,\n            b = d.pathfinder;\n        d = d.renderer;\n        var h = \"start\" === e ? this.fromPoint : this.toPoint,\n            m = h.getPathfinderAnchorPoint(a);\n\n        if (a.enabled && ((c = \"start\" === e ? c[1] : c[c.length - 2]) && \"M\" === c[0] || \"L\" === c[0])) {\n          c = {\n            x: c[1],\n            y: c[2]\n          };\n          c = h.getRadiansToVector(c, m);\n          m = h.getMarkerVector(c, a.radius, m);\n          c = -c / g;\n\n          if (a.width && a.height) {\n            var l = a.width;\n            var A = a.height;\n          } else l = A = 2 * a.radius;\n\n          this.graphics = this.graphics || {};\n          m = {\n            x: m.x - l / 2,\n            y: m.y - A / 2,\n            width: l,\n            height: A,\n            rotation: c,\n            rotationOriginX: m.x,\n            rotationOriginY: m.y\n          };\n          this.graphics[e] ? this.graphics[e].animate(m) : (this.graphics[e] = d.symbol(a.symbol).addClass(\"highcharts-point-connecting-path-\" + e + \"-marker\").attr(m).add(b.group), d.styledMode || this.graphics[e].attr({\n            fill: a.color || this.fromPoint.color,\n            stroke: a.lineColor,\n            \"stroke-width\": a.lineWidth,\n            opacity: 0\n          }).animate({\n            opacity: 1\n          }, h.series.options.animation));\n        }\n      };\n\n      b.prototype.getPath = function (e) {\n        var a = this.pathfinder,\n            c = this.chart,\n            b = a.algorithms[e.type],\n            g = a.chartObstacles;\n        if (\"function\" !== typeof b) return h('\"' + e.type + '\" is not a Pathfinder algorithm.'), {\n          path: [],\n          obstacles: []\n        };\n        b.requiresObstacles && !g && (g = a.chartObstacles = a.getChartObstacles(e), c.options.connectors.algorithmMargin = e.algorithmMargin, a.chartObstacleMetrics = a.getObstacleMetrics(g));\n        return b(this.fromPoint.getPathfinderAnchorPoint(e.startMarker), this.toPoint.getPathfinderAnchorPoint(e.endMarker), d({\n          chartObstacles: g,\n          lineObstacles: a.lineObstacles || [],\n          obstacleMetrics: a.chartObstacleMetrics,\n          hardBounds: {\n            xMin: 0,\n            xMax: c.plotWidth,\n            yMin: 0,\n            yMax: c.plotHeight\n          },\n          obstacleOptions: {\n            margin: e.algorithmMargin\n          },\n          startDirectionX: a.getAlgorithmStartDirection(e.startMarker)\n        }, e));\n      };\n\n      b.prototype.render = function () {\n        var e = this.fromPoint,\n            a = e.series,\n            c = a.chart,\n            b = c.pathfinder,\n            g = d(c.options.connectors, a.options.connectors, e.options.connectors, this.options),\n            h = {};\n        c.styledMode || (h.stroke = g.lineColor || e.color, h[\"stroke-width\"] = g.lineWidth, g.dashStyle && (h.dashstyle = g.dashStyle));\n        h[\"class\"] = \"highcharts-point-connecting-path highcharts-color-\" + e.colorIndex;\n        g = d(h, g);\n        l(g.marker.radius) || (g.marker.radius = D(A(Math.ceil((g.algorithmMargin || 8) / 2) - 1, 1), 5));\n        e = this.getPath(g);\n        c = e.path;\n        e.obstacles && (b.lineObstacles = b.lineObstacles || [], b.lineObstacles = b.lineObstacles.concat(e.obstacles));\n        this.renderPath(c, h, a.options.animation);\n        this.addMarker(\"start\", d(g.marker, g.startMarker), c);\n        this.addMarker(\"end\", d(g.marker, g.endMarker), c);\n      };\n\n      b.prototype.destroy = function () {\n        this.graphics && (p(this.graphics, function (e) {\n          e.destroy();\n        }), delete this.graphics);\n      };\n\n      return b;\n    }();\n\n    b.Connection = t;\n    x(v.prototype, {\n      getPathfinderAnchorPoint: function getPathfinderAnchorPoint(d) {\n        var e = B(this);\n\n        switch (d.align) {\n          case \"right\":\n            var a = \"xMax\";\n            break;\n\n          case \"left\":\n            a = \"xMin\";\n        }\n\n        switch (d.verticalAlign) {\n          case \"top\":\n            var c = \"yMin\";\n            break;\n\n          case \"bottom\":\n            c = \"yMax\";\n        }\n\n        return {\n          x: a ? e[a] : (e.xMin + e.xMax) / 2,\n          y: c ? e[c] : (e.yMin + e.yMax) / 2\n        };\n      },\n      getRadiansToVector: function getRadiansToVector(d, e) {\n        var a;\n        l(e) || (a = B(this)) && (e = {\n          x: (a.xMin + a.xMax) / 2,\n          y: (a.yMin + a.yMax) / 2\n        });\n        return Math.atan2(e.y - d.y, d.x - e.x);\n      },\n      getMarkerVector: function getMarkerVector(d, e, a) {\n        var c = 2 * Math.PI,\n            b = B(this),\n            g = b.xMax - b.xMin,\n            h = b.yMax - b.yMin,\n            m = Math.atan2(h, g),\n            l = !1;\n        g /= 2;\n        var A = h / 2,\n            p = b.xMin + g;\n        b = b.yMin + A;\n\n        for (var D = p, t = b, u = 1, z = 1; d < -Math.PI;) {\n          d += c;\n        }\n\n        for (; d > Math.PI;) {\n          d -= c;\n        }\n\n        c = Math.tan(d);\n        d > -m && d <= m ? (z = -1, l = !0) : d > m && d <= Math.PI - m ? z = -1 : d > Math.PI - m || d <= -(Math.PI - m) ? (u = -1, l = !0) : u = -1;\n        l ? (D += u * g, t += z * g * c) : (D += h / (2 * c) * u, t += z * A);\n        a.x !== p && (D = a.x);\n        a.y !== b && (t = a.y);\n        return {\n          x: D + e * Math.cos(d),\n          y: t - e * Math.sin(d)\n        };\n      }\n    });\n    return t;\n  });\n  J(b, \"Gantt/PathfinderAlgorithms.js\", [b[\"Core/Utilities.js\"]], function (b) {\n    function t(d, b, h) {\n      h = h || 0;\n      var g = d.length - 1;\n      b -= 1e-7;\n\n      for (var e, a; h <= g;) {\n        if (e = g + h >> 1, a = b - d[e].xMin, 0 < a) h = e + 1;else if (0 > a) g = e - 1;else return e;\n      }\n\n      return 0 < h ? h - 1 : 0;\n    }\n\n    function v(d, b) {\n      for (var g = t(d, b.x + 1) + 1; g--;) {\n        var h;\n        if (h = d[g].xMax >= b.x) h = d[g], h = b.x <= h.xMax && b.x >= h.xMin && b.y <= h.yMax && b.y >= h.yMin;\n        if (h) return g;\n      }\n\n      return -1;\n    }\n\n    function u(d) {\n      var b = [];\n\n      if (d.length) {\n        b.push([\"M\", d[0].start.x, d[0].start.y]);\n\n        for (var g = 0; g < d.length; ++g) {\n          b.push([\"L\", d[g].end.x, d[g].end.y]);\n        }\n      }\n\n      return b;\n    }\n\n    function B(d, b) {\n      d.yMin = x(d.yMin, b.yMin);\n      d.yMax = h(d.yMax, b.yMax);\n      d.xMin = x(d.xMin, b.xMin);\n      d.xMax = h(d.xMax, b.xMax);\n    }\n\n    var l = b.pick,\n        h = Math.min,\n        x = Math.max,\n        d = Math.abs;\n\n    b = function b(_b3, h, p) {\n      function g(a, c, e, d, b) {\n        a = {\n          x: a.x,\n          y: a.y\n        };\n        a[c] = e[d || c] + (b || 0);\n        return a;\n      }\n\n      function e(a, c, e) {\n        var b = d(c[e] - a[e + \"Min\"]) > d(c[e] - a[e + \"Max\"]);\n        return g(c, e, a, e + (b ? \"Max\" : \"Min\"), b ? 1 : -1);\n      }\n\n      var a = [],\n          c = l(p.startDirectionX, d(h.x - _b3.x) > d(h.y - _b3.y)) ? \"x\" : \"y\",\n          r = p.chartObstacles,\n          A = v(r, _b3);\n      p = v(r, h);\n\n      if (-1 < p) {\n        var t = r[p];\n        p = e(t, h, c);\n        t = {\n          start: p,\n          end: h\n        };\n        var m = p;\n      } else m = h;\n\n      -1 < A && (r = r[A], p = e(r, _b3, c), a.push({\n        start: _b3,\n        end: p\n      }), p[c] >= _b3[c] === p[c] >= m[c] && (c = \"y\" === c ? \"x\" : \"y\", h = _b3[c] < h[c], a.push({\n        start: p,\n        end: g(p, c, r, c + (h ? \"Max\" : \"Min\"), h ? 1 : -1)\n      }), c = \"y\" === c ? \"x\" : \"y\"));\n      _b3 = a.length ? a[a.length - 1].end : _b3;\n      p = g(_b3, c, m);\n      a.push({\n        start: _b3,\n        end: p\n      });\n      c = g(p, \"y\" === c ? \"x\" : \"y\", m);\n      a.push({\n        start: p,\n        end: c\n      });\n      a.push(t);\n      return {\n        path: u(a),\n        obstacles: a\n      };\n    };\n\n    b.requiresObstacles = !0;\n\n    var p = function p(b, _p, D) {\n      function g(a, c, f) {\n        var k,\n            b = a.x < c.x ? 1 : -1;\n\n        if (a.x < c.x) {\n          var e = a;\n          var d = c;\n        } else e = c, d = a;\n\n        if (a.y < c.y) {\n          var n = a;\n          var q = c;\n        } else n = c, q = a;\n\n        for (k = 0 > b ? h(t(I, d.x), I.length - 1) : 0; I[k] && (0 < b && I[k].xMin <= d.x || 0 > b && I[k].xMax >= e.x);) {\n          if (I[k].xMin <= d.x && I[k].xMax >= e.x && I[k].yMin <= q.y && I[k].yMax >= n.y) return f ? {\n            y: a.y,\n            x: a.x < c.x ? I[k].xMin - 1 : I[k].xMax + 1,\n            obstacle: I[k]\n          } : {\n            x: a.x,\n            y: a.y < c.y ? I[k].yMin - 1 : I[k].yMax + 1,\n            obstacle: I[k]\n          };\n          k += b;\n        }\n\n        return c;\n      }\n\n      function e(a, c, f, k, b) {\n        var e = b.soft,\n            n = b.hard,\n            q = k ? \"x\" : \"y\",\n            w = {\n          x: c.x,\n          y: c.y\n        },\n            h = {\n          x: c.x,\n          y: c.y\n        };\n        b = a[q + \"Max\"] >= e[q + \"Max\"];\n        e = a[q + \"Min\"] <= e[q + \"Min\"];\n        var m = a[q + \"Max\"] >= n[q + \"Max\"];\n        n = a[q + \"Min\"] <= n[q + \"Min\"];\n        var y = d(a[q + \"Min\"] - c[q]),\n            r = d(a[q + \"Max\"] - c[q]);\n        f = 10 > d(y - r) ? c[q] < f[q] : r < y;\n        h[q] = a[q + \"Min\"];\n        w[q] = a[q + \"Max\"];\n        a = g(c, h, k)[q] !== h[q];\n        c = g(c, w, k)[q] !== w[q];\n        f = a ? c ? f : !0 : c ? !1 : f;\n        f = e ? b ? f : !0 : b ? !1 : f;\n        return n ? m ? f : !0 : m ? !1 : f;\n      }\n\n      function a(c, b, f) {\n        if (c.x === b.x && c.y === b.y) return [];\n        var k = f ? \"x\" : \"y\",\n            d = D.obstacleOptions.margin;\n        var n = {\n          soft: {\n            xMin: Q,\n            xMax: M,\n            yMin: E,\n            yMax: K\n          },\n          hard: D.hardBounds\n        };\n        var q = v(I, c);\n\n        if (-1 < q) {\n          q = I[q];\n          n = e(q, c, b, f, n);\n          B(q, D.hardBounds);\n          var r = f ? {\n            y: c.y,\n            x: q[n ? \"xMax\" : \"xMin\"] + (n ? 1 : -1)\n          } : {\n            x: c.x,\n            y: q[n ? \"yMax\" : \"yMin\"] + (n ? 1 : -1)\n          };\n          var y = v(I, r);\n          -1 < y && (y = I[y], B(y, D.hardBounds), r[k] = n ? x(q[k + \"Max\"] - d + 1, (y[k + \"Min\"] + q[k + \"Max\"]) / 2) : h(q[k + \"Min\"] + d - 1, (y[k + \"Max\"] + q[k + \"Min\"]) / 2), c.x === r.x && c.y === r.y ? (m && (r[k] = n ? x(q[k + \"Max\"], y[k + \"Max\"]) + 1 : h(q[k + \"Min\"], y[k + \"Min\"]) - 1), m = !m) : m = !1);\n          c = [{\n            start: c,\n            end: r\n          }];\n        } else k = g(c, {\n          x: f ? b.x : c.x,\n          y: f ? c.y : b.y\n        }, f), c = [{\n          start: c,\n          end: {\n            x: k.x,\n            y: k.y\n          }\n        }], k[f ? \"x\" : \"y\"] !== b[f ? \"x\" : \"y\"] && (n = e(k.obstacle, k, b, !f, n), B(k.obstacle, D.hardBounds), n = {\n          x: f ? k.x : k.obstacle[n ? \"xMax\" : \"xMin\"] + (n ? 1 : -1),\n          y: f ? k.obstacle[n ? \"yMax\" : \"yMin\"] + (n ? 1 : -1) : k.y\n        }, f = !f, c = c.concat(a({\n          x: k.x,\n          y: k.y\n        }, n, f)));\n\n        return c = c.concat(a(c[c.length - 1].end, b, !f));\n      }\n\n      function c(a, c, f) {\n        var k = h(a.xMax - c.x, c.x - a.xMin) < h(a.yMax - c.y, c.y - a.yMin);\n        f = e(a, c, f, k, {\n          soft: D.hardBounds,\n          hard: D.hardBounds\n        });\n        return k ? {\n          y: c.y,\n          x: a[f ? \"xMax\" : \"xMin\"] + (f ? 1 : -1)\n        } : {\n          x: c.x,\n          y: a[f ? \"yMax\" : \"yMin\"] + (f ? 1 : -1)\n        };\n      }\n\n      var r = l(D.startDirectionX, d(_p.x - b.x) > d(_p.y - b.y)),\n          A = r ? \"x\" : \"y\",\n          G = [],\n          m = !1,\n          C = D.obstacleMetrics,\n          Q = h(b.x, _p.x) - C.maxWidth - 10,\n          M = x(b.x, _p.x) + C.maxWidth + 10,\n          E = h(b.y, _p.y) - C.maxHeight - 10,\n          K = x(b.y, _p.y) + C.maxHeight + 10,\n          I = D.chartObstacles;\n      var z = t(I, Q);\n      C = t(I, M);\n      I = I.slice(z, C + 1);\n\n      if (-1 < (C = v(I, _p))) {\n        var n = c(I[C], _p, b);\n        G.push({\n          end: _p,\n          start: n\n        });\n        _p = n;\n      }\n\n      for (; -1 < (C = v(I, _p));) {\n        z = 0 > _p[A] - b[A], n = {\n          x: _p.x,\n          y: _p.y\n        }, n[A] = I[C][z ? A + \"Max\" : A + \"Min\"] + (z ? 1 : -1), G.push({\n          end: _p,\n          start: n\n        }), _p = n;\n      }\n\n      b = a(b, _p, r);\n      b = b.concat(G.reverse());\n      return {\n        path: u(b),\n        obstacles: b\n      };\n    };\n\n    p.requiresObstacles = !0;\n    return {\n      fastAvoid: p,\n      straight: function straight(b, d) {\n        return {\n          path: [[\"M\", b.x, b.y], [\"L\", d.x, d.y]],\n          obstacles: [{\n            start: b,\n            end: d\n          }]\n        };\n      },\n      simpleConnect: b\n    };\n  });\n  J(b, \"Gantt/Pathfinder.js\", [b[\"Gantt/Connection.js\"], b[\"Core/Chart/Chart.js\"], b[\"Core/Globals.js\"], b[\"Core/DefaultOptions.js\"], b[\"Core/Series/Point.js\"], b[\"Core/Utilities.js\"], b[\"Gantt/PathfinderAlgorithms.js\"]], function (b, t, v, u, B, l, h) {\n    function x(a) {\n      var c = a.shapeArgs;\n      return c ? {\n        xMin: c.x || 0,\n        xMax: (c.x || 0) + (c.width || 0),\n        yMin: c.y || 0,\n        yMax: (c.y || 0) + (c.height || 0)\n      } : (c = a.graphic && a.graphic.getBBox()) ? {\n        xMin: a.plotX - c.width / 2,\n        xMax: a.plotX + c.width / 2,\n        yMin: a.plotY - c.height / 2,\n        yMax: a.plotY + c.height / 2\n      } : null;\n    }\n\n    function d(c) {\n      for (var b = c.length, e = 0, d, g, h = [], m = function m(c, b, e) {\n        e = a(e, 10);\n        var d = c.yMax + e > b.yMin - e && c.yMin - e < b.yMax + e,\n            f = c.xMax + e > b.xMin - e && c.xMin - e < b.xMax + e,\n            k = d ? c.xMin > b.xMax ? c.xMin - b.xMax : b.xMin - c.xMax : Infinity,\n            n = f ? c.yMin > b.yMax ? c.yMin - b.yMax : b.yMin - c.yMax : Infinity;\n        return f && d ? e ? m(c, b, Math.floor(e / 2)) : Infinity : F(k, n);\n      }; e < b; ++e) {\n        for (d = e + 1; d < b; ++d) {\n          g = m(c[e], c[d]), 80 > g && h.push(g);\n        }\n      }\n\n      h.push(80);\n      return r(Math.floor(h.sort(function (a, c) {\n        return a - c;\n      })[Math.floor(h.length / 10)] / 2 - 1), 1);\n    }\n\n    function p(a) {\n      if (a.options.pathfinder || a.series.reduce(function (a, c) {\n        c.options && e(!0, c.options.connectors = c.options.connectors || {}, c.options.pathfinder);\n        return a || c.options && c.options.pathfinder;\n      }, !1)) e(!0, a.options.connectors = a.options.connectors || {}, a.options.pathfinder), D('WARNING: Pathfinder options have been renamed. Use \"chart.connectors\" or \"series.connectors\" instead.');\n    }\n\n    \"\";\n    var g = l.addEvent,\n        A = l.defined,\n        D = l.error,\n        H = l.extend,\n        e = l.merge,\n        a = l.pick,\n        c = l.splat,\n        r = Math.max,\n        F = Math.min;\n    H(u.defaultOptions, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n\n    var G = function () {\n      function e(a) {\n        this.lineObstacles = this.group = this.connections = this.chartObstacleMetrics = this.chartObstacles = this.chart = void 0;\n        this.init(a);\n      }\n\n      e.prototype.init = function (a) {\n        this.chart = a;\n        this.connections = [];\n        g(a, \"redraw\", function () {\n          this.pathfinder.update();\n        });\n      };\n\n      e.prototype.update = function (a) {\n        var e = this.chart,\n            d = this,\n            g = d.connections;\n        d.connections = [];\n        e.series.forEach(function (a) {\n          a.visible && !a.options.isInternal && a.points.forEach(function (f) {\n            var a = f.options;\n            a && a.dependency && (a.connect = a.dependency);\n            var n;\n            a = f.options && f.options.connect && c(f.options.connect);\n            f.visible && !1 !== f.isInside && a && a.forEach(function (a) {\n              n = e.get(\"string\" === typeof a ? a : a.to);\n              n instanceof B && n.series.visible && n.visible && !1 !== n.isInside && d.connections.push(new b(f, n, \"string\" === typeof a ? {} : a));\n            });\n          });\n        });\n\n        for (var h = 0, r = void 0, m = void 0, n = g.length, y = d.connections.length; h < n; ++h) {\n          m = !1;\n\n          for (r = 0; r < y; ++r) {\n            if (g[h].fromPoint === d.connections[r].fromPoint && g[h].toPoint === d.connections[r].toPoint) {\n              d.connections[r].graphics = g[h].graphics;\n              m = !0;\n              break;\n            }\n          }\n\n          m || g[h].destroy();\n        }\n\n        delete this.chartObstacles;\n        delete this.lineObstacles;\n        d.renderConnections(a);\n      };\n\n      e.prototype.renderConnections = function (a) {\n        a ? this.chart.series.forEach(function (a) {\n          var c = function c() {\n            var c = a.chart.pathfinder;\n            (c && c.connections || []).forEach(function (c) {\n              c.fromPoint && c.fromPoint.series === a && c.render();\n            });\n            a.pathfinderRemoveRenderEvent && (a.pathfinderRemoveRenderEvent(), delete a.pathfinderRemoveRenderEvent);\n          };\n\n          !1 === a.options.animation ? c() : a.pathfinderRemoveRenderEvent = g(a, \"afterAnimate\", c);\n        }) : this.connections.forEach(function (a) {\n          a.render();\n        });\n      };\n\n      e.prototype.getChartObstacles = function (c) {\n        for (var b = [], e = this.chart.series, g = a(c.algorithmMargin, 0), h, r = 0, m = e.length; r < m; ++r) {\n          if (e[r].visible && !e[r].options.isInternal) {\n            var n = 0,\n                y = e[r].points.length,\n                q = void 0;\n\n            for (q = void 0; n < y; ++n) {\n              q = e[r].points[n], q.visible && (q = x(q)) && b.push({\n                xMin: q.xMin - g,\n                xMax: q.xMax + g,\n                yMin: q.yMin - g,\n                yMax: q.yMax + g\n              });\n            }\n          }\n        }\n\n        b = b.sort(function (f, a) {\n          return f.xMin - a.xMin;\n        });\n        A(c.algorithmMargin) || (h = c.algorithmMargin = d(b), b.forEach(function (f) {\n          f.xMin -= h;\n          f.xMax += h;\n          f.yMin -= h;\n          f.yMax += h;\n        }));\n        return b;\n      };\n\n      e.prototype.getObstacleMetrics = function (a) {\n        for (var c = 0, b = 0, e, d, g = a.length; g--;) {\n          e = a[g].xMax - a[g].xMin, d = a[g].yMax - a[g].yMin, c < e && (c = e), b < d && (b = d);\n        }\n\n        return {\n          maxHeight: b,\n          maxWidth: c\n        };\n      };\n\n      e.prototype.getAlgorithmStartDirection = function (a) {\n        var c = \"top\" !== a.verticalAlign && \"bottom\" !== a.verticalAlign;\n        return \"left\" !== a.align && \"right\" !== a.align ? c ? void 0 : !1 : c ? !0 : void 0;\n      };\n\n      return e;\n    }();\n\n    G.prototype.algorithms = h;\n    v.Pathfinder = G;\n    H(B.prototype, {\n      getPathfinderAnchorPoint: function getPathfinderAnchorPoint(a) {\n        var c = x(this);\n\n        switch (a.align) {\n          case \"right\":\n            var b = \"xMax\";\n            break;\n\n          case \"left\":\n            b = \"xMin\";\n        }\n\n        switch (a.verticalAlign) {\n          case \"top\":\n            var e = \"yMin\";\n            break;\n\n          case \"bottom\":\n            e = \"yMax\";\n        }\n\n        return {\n          x: b ? c[b] : (c.xMin + c.xMax) / 2,\n          y: e ? c[e] : (c.yMin + c.yMax) / 2\n        };\n      },\n      getRadiansToVector: function getRadiansToVector(a, c) {\n        var b;\n        A(c) || (b = x(this)) && (c = {\n          x: (b.xMin + b.xMax) / 2,\n          y: (b.yMin + b.yMax) / 2\n        });\n        return Math.atan2(c.y - a.y, a.x - c.x);\n      },\n      getMarkerVector: function getMarkerVector(a, c, b) {\n        var e = 2 * Math.PI,\n            d = x(this),\n            g = d.xMax - d.xMin,\n            h = d.yMax - d.yMin,\n            r = Math.atan2(h, g),\n            n = !1;\n        g /= 2;\n        var m = h / 2,\n            q = d.xMin + g;\n        d = d.yMin + m;\n\n        for (var f = q, k = d, w = 1, L = 1; a < -Math.PI;) {\n          a += e;\n        }\n\n        for (; a > Math.PI;) {\n          a -= e;\n        }\n\n        e = Math.tan(a);\n        a > -r && a <= r ? (L = -1, n = !0) : a > r && a <= Math.PI - r ? L = -1 : a > Math.PI - r || a <= -(Math.PI - r) ? (w = -1, n = !0) : w = -1;\n        n ? (f += w * g, k += L * g * e) : (f += h / (2 * e) * w, k += L * m);\n        b.x !== q && (f = b.x);\n        b.y !== d && (k = b.y);\n        return {\n          x: f + c * Math.cos(a),\n          y: k - c * Math.sin(a)\n        };\n      }\n    });\n    t.prototype.callbacks.push(function (a) {\n      !1 !== a.options.connectors.enabled && (p(a), this.pathfinder = new G(this), this.pathfinder.update(!0));\n    });\n    return G;\n  });\n  J(b, \"Series/Gantt/GanttSeries.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Chart/Chart.js\"], b[\"Series/Gantt/GanttPoint.js\"], b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Axis/Tick.js\"], b[\"Core/Utilities.js\"], b[\"Core/Axis/TreeGridAxis.js\"]], function (b, t, v, u, B, l, h) {\n    var x = this && this.__extends || function () {\n      var _b4 = function b(e, a) {\n        _b4 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) {\n            b.hasOwnProperty(c) && (a[c] = b[c]);\n          }\n        };\n\n        return _b4(e, a);\n      };\n\n      return function (e, a) {\n        function c() {\n          this.constructor = e;\n        }\n\n        _b4(e, a);\n\n        e.prototype = null === a ? Object.create(a) : (c.prototype = a.prototype, new c());\n      };\n    }(),\n        d = u.series,\n        p = u.seriesTypes.xrange,\n        g = l.extend,\n        A = l.isNumber,\n        D = l.merge;\n\n    h.compose(b, t, d, B);\n\n    b = function (b) {\n      function e() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      x(e, b);\n\n      e.prototype.drawPoint = function (a, c) {\n        var b = this.options,\n            e = this.chart.renderer,\n            d = a.shapeArgs,\n            g = a.plotY,\n            h = a.graphic,\n            l = a.selected && \"select\",\n            t = b.stacking && !b.borderRadius;\n        if (a.options.milestone) {\n          if (A(g) && null !== a.y && !1 !== a.visible) {\n            d = e.symbols.diamond(d.x || 0, d.y || 0, d.width || 0, d.height || 0);\n            if (h) h[c]({\n              d: d\n            });else a.graphic = e.path(d).addClass(a.getClassName(), !0).add(a.group || this.group);\n            this.chart.styledMode || a.graphic.attr(this.pointAttribs(a, l)).shadow(b.shadow, null, t);\n          } else h && (a.graphic = h.destroy());\n        } else p.prototype.drawPoint.call(this, a, c);\n      };\n\n      e.prototype.translatePoint = function (a) {\n        p.prototype.translatePoint.call(this, a);\n\n        if (a.options.milestone) {\n          var c = a.shapeArgs;\n          var b = c.height || 0;\n          a.shapeArgs = {\n            x: (c.x || 0) - b / 2,\n            y: c.y,\n            width: b,\n            height: b\n          };\n        }\n      };\n\n      e.defaultOptions = D(p.defaultOptions, {\n        grouping: !1,\n        dataLabels: {\n          enabled: !0\n        },\n        tooltip: {\n          headerFormat: '<span style=\"font-size: 10px\">{series.name}</span><br/>',\n          pointFormat: null,\n          pointFormatter: function pointFormatter() {\n            var a = this.series,\n                c = a.xAxis,\n                b = a.tooltipOptions.dateTimeLabelFormats,\n                e = c.options.startOfWeek,\n                d = a.tooltipOptions,\n                g = d.xDateFormat,\n                h = this.options.milestone,\n                l = \"<b>\" + (this.name || this.yCategory) + \"</b>\";\n            if (d.pointFormat) return this.tooltipFormatter(d.pointFormat);\n            !g && A(this.start) && (g = a.chart.time.getDateFormat(c.closestPointRange, this.start, e, b || {}));\n            c = a.chart.time.dateFormat(g, this.start);\n            a = a.chart.time.dateFormat(g, this.end);\n            l += \"<br/>\";\n            return h ? l + (c + \"<br/>\") : l + (\"Start: \" + c + \"<br/>End: \") + (a + \"<br/>\");\n          }\n        },\n        connectors: {\n          type: \"simpleConnect\",\n          animation: {\n            reversed: !0\n          },\n          startMarker: {\n            enabled: !0,\n            symbol: \"arrow-filled\",\n            radius: 4,\n            fill: \"#fa0\",\n            align: \"left\"\n          },\n          endMarker: {\n            enabled: !1,\n            align: \"right\"\n          }\n        }\n      });\n      return e;\n    }(p);\n\n    g(b.prototype, {\n      pointArrayMap: [\"start\", \"end\", \"y\"],\n      pointClass: v,\n      setData: d.prototype.setData\n    });\n    u.registerSeriesType(\"gantt\", b);\n    \"\";\n    return b;\n  });\n  J(b, \"Core/Chart/GanttChart.js\", [b[\"Core/Chart/Chart.js\"], b[\"Core/DefaultOptions.js\"], b[\"Core/Utilities.js\"]], function (b, t, v) {\n    var u = this && this.__extends || function () {\n      var _b5 = function b(d, g) {\n        _b5 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var g in d) {\n            d.hasOwnProperty(g) && (b[g] = d[g]);\n          }\n        };\n\n        return _b5(d, g);\n      };\n\n      return function (d, g) {\n        function h() {\n          this.constructor = d;\n        }\n\n        _b5(d, g);\n\n        d.prototype = null === g ? Object.create(g) : (h.prototype = g.prototype, new h());\n      };\n    }(),\n        B = t.getOptions,\n        l = v.isArray,\n        h = v.merge,\n        x = v.splat;\n\n    b = function (b) {\n      function d() {\n        return null !== b && b.apply(this, arguments) || this;\n      }\n\n      u(d, b);\n\n      d.prototype.init = function (d, p) {\n        var g = B(),\n            t = d.xAxis,\n            e = d.yAxis,\n            a;\n        d.xAxis = d.yAxis = void 0;\n        var c = h(!0, {\n          chart: {\n            type: \"gantt\"\n          },\n          title: {\n            text: null\n          },\n          legend: {\n            enabled: !1\n          },\n          navigator: {\n            series: {\n              type: \"gantt\"\n            },\n            yAxis: {\n              type: \"category\"\n            }\n          }\n        }, d, {\n          isGantt: !0\n        });\n        d.xAxis = t;\n        d.yAxis = e;\n        c.xAxis = (l(d.xAxis) ? d.xAxis : [d.xAxis || {}, {}]).map(function (c, b) {\n          1 === b && (a = 0);\n          return h(g.xAxis, {\n            grid: {\n              enabled: !0\n            },\n            opposite: !0,\n            linkedTo: a\n          }, c, {\n            type: \"datetime\"\n          });\n        });\n        c.yAxis = x(d.yAxis || {}).map(function (a) {\n          return h(g.yAxis, {\n            grid: {\n              enabled: !0\n            },\n            staticScale: 50,\n            reversed: !0,\n            type: a.categories ? a.type : \"treegrid\"\n          }, a);\n        });\n        b.prototype.init.call(this, c, p);\n      };\n\n      return d;\n    }(b);\n\n    (function (b) {\n      b.ganttChart = function (d, g, h) {\n        return new b(d, g, h);\n      };\n    })(b || (b = {}));\n\n    return b;\n  });\n  J(b, \"Core/Axis/ScrollbarAxis.js\", [b[\"Core/Utilities.js\"]], function (b) {\n    var t = b.addEvent,\n        v = b.defined,\n        u = b.pick;\n    return function () {\n      function b() {}\n\n      b.compose = function (l, h) {\n        if (-1 === b.composed.indexOf(l)) b.composed.push(l);else return l;\n\n        var x = function x(b) {\n          var d = u(b.options && b.options.min, b.min),\n              g = u(b.options && b.options.max, b.max);\n          return {\n            axisMin: d,\n            axisMax: g,\n            scrollMin: v(b.dataMin) ? Math.min(d, b.min, b.dataMin, u(b.threshold, Infinity)) : d,\n            scrollMax: v(b.dataMax) ? Math.max(g, b.max, b.dataMax, u(b.threshold, -Infinity)) : g\n          };\n        };\n\n        t(l, \"afterInit\", function () {\n          var b = this;\n          b.options && b.options.scrollbar && b.options.scrollbar.enabled && (b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new h(b.chart.renderer, b.options.scrollbar, b.chart), t(b.scrollbar, \"changed\", function (d) {\n            var g = x(b),\n                h = g.axisMax,\n                l = g.scrollMin,\n                p = g.scrollMax - l;\n            v(g.axisMin) && v(h) && (b.horiz && !b.reversed || !b.horiz && b.reversed ? (g = l + p * this.to, l += p * this.from) : (g = l + p * (1 - this.from), l += p * (1 - this.to)), this.shouldUpdateExtremes(d.DOMType) ? b.setExtremes(l, g, !0, \"mousemove\" !== d.DOMType && \"touchmove\" !== d.DOMType, d) : this.setRange(this.from, this.to));\n          }));\n        });\n        t(l, \"afterRender\", function () {\n          var b = x(this),\n              h = b.scrollMin,\n              g = b.scrollMax;\n          b = this.scrollbar;\n          var l = this.axisTitleMargin + (this.titleOffset || 0),\n              t = this.chart.scrollbarsOffsets,\n              u = this.options.margin || 0;\n          b && (this.horiz ? (this.opposite || (t[1] += l), b.position(this.left, this.top + this.height + 2 + t[1] - (this.opposite ? u : 0), this.width, this.height), this.opposite || (t[1] += u), l = 1) : (this.opposite && (t[0] += l), b.position(b.options.opposite ? this.left + this.width + 2 + t[0] - (this.opposite ? 0 : u) : this.opposite ? 0 : u, this.top, this.width, this.height), this.opposite && (t[0] += u), l = 0), t[l] += b.size + b.options.margin, isNaN(h) || isNaN(g) || !v(this.min) || !v(this.max) || this.min === this.max ? b.setRange(0, 1) : (t = (this.min - h) / (g - h), h = (this.max - h) / (g - h), this.horiz && !this.reversed || !this.horiz && this.reversed ? b.setRange(t, h) : b.setRange(1 - h, 1 - t)));\n        });\n        t(l, \"afterGetOffset\", function () {\n          var b = this.scrollbar && !this.scrollbar.options.opposite;\n          b = this.horiz ? 2 : b ? 3 : 1;\n          var h = this.scrollbar;\n          h && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[b] += h.size + h.options.margin);\n        });\n        return l;\n      };\n\n      b.composed = [];\n      return b;\n    }();\n  });\n  J(b, \"Core/ScrollbarDefaults.js\", [b[\"Core/Globals.js\"]], function (b) {\n    return {\n      height: b.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n  });\n  J(b, \"Core/Scrollbar.js\", [b[\"Core/DefaultOptions.js\"], b[\"Core/Globals.js\"], b[\"Core/Axis/ScrollbarAxis.js\"], b[\"Core/ScrollbarDefaults.js\"], b[\"Core/Utilities.js\"]], function (b, t, v, u, B) {\n    var l = b.defaultOptions,\n        h = B.addEvent,\n        x = B.correctFloat,\n        d = B.defined,\n        p = B.destroyObjectProperties,\n        g = B.fireEvent,\n        A = B.merge,\n        D = B.pick,\n        H = B.removeEvent;\n\n    b = function () {\n      function b(a, c, b) {\n        this._events = [];\n        this.chart = void 0;\n        this.from = this.chartY = this.chartX = 0;\n        this.scrollbar = this.renderer = this.options = this.group = void 0;\n        this.scrollbarButtons = [];\n        this.scrollbarGroup = void 0;\n        this.scrollbarLeft = 0;\n        this.scrollbarRifles = void 0;\n        this.scrollbarStrokeWidth = 1;\n        this.to = this.size = this.scrollbarTop = 0;\n        this.track = void 0;\n        this.trackBorderWidth = 1;\n        this.userOptions = void 0;\n        this.y = this.x = 0;\n        this.init(a, c, b);\n      }\n\n      b.compose = function (a) {\n        v.compose(a, b);\n      };\n\n      b.swapXY = function (a, c) {\n        c && a.forEach(function (a) {\n          for (var c = a.length, b, e = 0; e < c; e += 2) {\n            b = a[e + 1], \"number\" === typeof b && (a[e + 1] = a[e + 2], a[e + 2] = b);\n          }\n        });\n        return a;\n      };\n\n      b.prototype.addEvents = function () {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            c = this.scrollbarButtons,\n            b = this.scrollbarGroup.element,\n            e = this.track.element,\n            d = this.mouseDownHandler.bind(this),\n            g = this.mouseMoveHandler.bind(this),\n            l = this.mouseUpHandler.bind(this);\n        a = [[c[a[0]].element, \"click\", this.buttonToMinClick.bind(this)], [c[a[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [e, \"click\", this.trackClick.bind(this)], [b, \"mousedown\", d], [b.ownerDocument, \"mousemove\", g], [b.ownerDocument, \"mouseup\", l]];\n        t.hasTouch && a.push([b, \"touchstart\", d], [b.ownerDocument, \"touchmove\", g], [b.ownerDocument, \"touchend\", l]);\n        a.forEach(function (a) {\n          h.apply(null, a);\n        });\n        this._events = a;\n      };\n\n      b.prototype.buttonToMaxClick = function (a) {\n        var c = (this.to - this.from) * D(this.options.step, .2);\n        this.updatePosition(this.from + c, this.to + c);\n        g(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      b.prototype.buttonToMinClick = function (a) {\n        var c = x(this.to - this.from) * D(this.options.step, .2);\n        this.updatePosition(x(this.from - c), x(this.to - c));\n        g(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      b.prototype.cursorToScrollbarPosition = function (a) {\n        var c = this.options;\n        c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - c),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - c)\n        };\n      };\n\n      b.prototype.destroy = function () {\n        var a = this,\n            c = a.chart.scroller;\n        a.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (c) {\n          a[c] && a[c].destroy && (a[c] = a[c].destroy());\n        });\n        c && a === c.scrollbar && (c.scrollbar = null, p(c.scrollbarButtons));\n      };\n\n      b.prototype.drawScrollbarButton = function (a) {\n        var c = this.renderer,\n            e = this.scrollbarButtons,\n            d = this.options,\n            g = this.size,\n            h = c.g().add(this.group);\n        e.push(h);\n        h = c.rect().addClass(\"highcharts-scrollbar-button\").add(h);\n        this.chart.styledMode || h.attr({\n          stroke: d.buttonBorderColor,\n          \"stroke-width\": d.buttonBorderWidth,\n          fill: d.buttonBackgroundColor\n        });\n        h.attr(h.crisp({\n          x: -.5,\n          y: -.5,\n          width: g + 1,\n          height: g + 1,\n          r: d.buttonBorderRadius\n        }, h.strokeWidth()));\n        h = c.path(b.swapXY([[\"M\", g / 2 + (a ? -1 : 1), g / 2 - 3], [\"L\", g / 2 + (a ? -1 : 1), g / 2 + 3], [\"L\", g / 2 + (a ? 2 : -2), g / 2]], d.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(e[a]);\n        this.chart.styledMode || h.attr({\n          fill: d.buttonArrowColor\n        });\n      };\n\n      b.prototype.init = function (a, c, b) {\n        this.scrollbarButtons = [];\n        this.renderer = a;\n        this.userOptions = c;\n        this.options = A(u, l.scrollbar, c);\n        this.chart = b;\n        this.size = D(this.options.size, this.options.height);\n        c.enabled && (this.render(), this.addEvents());\n      };\n\n      b.prototype.mouseDownHandler = function (a) {\n        a = this.chart.pointer.normalize(a);\n        a = this.cursorToScrollbarPosition(a);\n        this.chartX = a.chartX;\n        this.chartY = a.chartY;\n        this.initPositions = [this.from, this.to];\n        this.grabbedCenter = !0;\n      };\n\n      b.prototype.mouseMoveHandler = function (a) {\n        var c = this.chart.pointer.normalize(a),\n            b = this.options.vertical ? \"chartY\" : \"chartX\",\n            e = this.initPositions || [];\n        !this.grabbedCenter || a.touches && 0 === a.touches[0][b] || (c = this.cursorToScrollbarPosition(c)[b], b = this[b], b = c - b, this.hasDragged = !0, this.updatePosition(e[0] + b, e[1] + b), this.hasDragged && g(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        }));\n      };\n\n      b.prototype.mouseUpHandler = function (a) {\n        this.hasDragged && g(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        });\n        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n      };\n\n      b.prototype.position = function (a, c, b, e) {\n        var d = this.options.vertical,\n            g = this.rendered ? \"animate\" : \"attr\",\n            h = 0;\n        this.x = a;\n        this.y = c + this.trackBorderWidth;\n        this.width = b;\n        this.xOffset = this.height = e;\n        this.yOffset = h;\n        d ? (this.width = this.yOffset = b = h = this.size, this.xOffset = c = 0, this.barWidth = e - 2 * b, this.x = a += this.options.margin) : (this.height = this.xOffset = e = c = this.size, this.barWidth = b - 2 * e, this.y += this.options.margin);\n        this.group[g]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[g]({\n          width: b,\n          height: e\n        });\n        this.scrollbarButtons[1][g]({\n          translateX: d ? 0 : b - c,\n          translateY: d ? e - h : 0\n        });\n      };\n\n      b.prototype.removeEvents = function () {\n        this._events.forEach(function (a) {\n          H.apply(null, a);\n        });\n\n        this._events.length = 0;\n      };\n\n      b.prototype.render = function () {\n        var a = this.renderer,\n            c = this.options,\n            e = this.size,\n            d = this.chart.styledMode,\n            g = a.g(\"scrollbar\").attr({\n          zIndex: c.zIndex,\n          translateY: -99999\n        }).add();\n        this.group = g;\n        this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: c.trackBorderRadius || 0,\n          height: e,\n          width: e\n        }).add(g);\n        d || this.track.attr({\n          fill: c.trackBackgroundColor,\n          stroke: c.trackBorderColor,\n          \"stroke-width\": c.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = a.g().add(g);\n        this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: e,\n          width: e,\n          r: c.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = a.path(b.swapXY([[\"M\", -3, e / 4], [\"L\", -3, 2 * e / 3], [\"M\", 0, e / 4], [\"L\", 0, 2 * e / 3], [\"M\", 3, e / 4], [\"L\", 3, 2 * e / 3]], c.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        d || (this.scrollbar.attr({\n          fill: c.barBackgroundColor,\n          stroke: c.barBorderColor,\n          \"stroke-width\": c.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: c.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      };\n\n      b.prototype.setRange = function (a, c) {\n        var b = this.options,\n            e = b.vertical,\n            g = b.minWidth,\n            h = this.barWidth,\n            l = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n\n        if (d(h)) {\n          var p = h * Math.min(c, 1);\n          a = Math.max(a, 0);\n          var t = Math.ceil(h * a);\n          this.calculatedWidth = p = x(p - t);\n          p < g && (t = (h - g + p) * a, p = g);\n          g = Math.floor(t + this.xOffset + this.yOffset);\n          h = p / 2 - .5;\n          this.from = a;\n          this.to = c;\n          e ? (this.scrollbarGroup[l]({\n            translateY: g\n          }), this.scrollbar[l]({\n            height: p\n          }), this.scrollbarRifles[l]({\n            translateY: h\n          }), this.scrollbarTop = g, this.scrollbarLeft = 0) : (this.scrollbarGroup[l]({\n            translateX: g\n          }), this.scrollbar[l]({\n            width: p\n          }), this.scrollbarRifles[l]({\n            translateX: h\n          }), this.scrollbarLeft = g, this.scrollbarTop = 0);\n          12 >= p ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);\n          !1 === b.showFull && (0 >= a && 1 <= c ? this.group.hide() : this.group.show());\n          this.rendered = !0;\n        }\n      };\n\n      b.prototype.shouldUpdateExtremes = function (a) {\n        return D(this.options.liveRedraw, t.svg && !t.isTouchDevice && !this.chart.isBoosting) || \"mouseup\" === a || \"touchend\" === a || !d(a);\n      };\n\n      b.prototype.trackClick = function (a) {\n        var c = this.chart.pointer.normalize(a),\n            b = this.to - this.from,\n            e = this.y + this.scrollbarTop,\n            d = this.x + this.scrollbarLeft;\n        this.options.vertical && c.chartY > e || !this.options.vertical && c.chartX > d ? this.updatePosition(this.from + b, this.to + b) : this.updatePosition(this.from - b, this.to - b);\n        g(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      b.prototype.update = function (a) {\n        this.destroy();\n        this.init(this.chart.renderer, A(!0, this.options, a), this.chart);\n      };\n\n      b.prototype.updatePosition = function (a, c) {\n        1 < c && (a = x(1 - x(c - a)), c = 1);\n        0 > a && (c = x(c - a), a = 0);\n        this.from = a;\n        this.to = c;\n      };\n\n      b.defaultOptions = u;\n      return b;\n    }();\n\n    l.scrollbar = A(!0, b.defaultOptions, l.scrollbar);\n    return b;\n  });\n  J(b, \"Extensions/RangeSelector.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Chart/Chart.js\"], b[\"Core/Globals.js\"], b[\"Core/DefaultOptions.js\"], b[\"Core/Renderer/SVG/SVGElement.js\"], b[\"Core/Utilities.js\"]], function (b, t, v, u, B, l) {\n    function h(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      var c = \"aAdewbBmoyY\".split(\"\").some(function (c) {\n        return -1 !== a.indexOf(\"%\" + c);\n      }),\n          b = \"HkIlMS\".split(\"\").some(function (c) {\n        return -1 !== a.indexOf(\"%\" + c);\n      });\n      return c && b ? \"datetime-local\" : c ? \"date\" : b ? \"time\" : \"text\";\n    }\n\n    var x = u.defaultOptions,\n        d = l.addEvent,\n        p = l.createElement,\n        g = l.css,\n        A = l.defined,\n        D = l.destroyObjectProperties,\n        H = l.discardElement,\n        e = l.extend,\n        a = l.find,\n        c = l.fireEvent,\n        r = l.isNumber,\n        F = l.merge,\n        G = l.objectEach,\n        m = l.pad,\n        C = l.pick,\n        J = l.pInt,\n        M = l.splat;\n    e(x, {\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%b %e, %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#335cad\",\n          cursor: \"pointer\"\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    e(x.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"\",\n      rangeSelectorTo: \"\\u2192\"\n    });\n\n    var E = function () {\n      function a(c) {\n        this.buttons = void 0;\n        this.buttonOptions = a.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = c;\n        this.init(c);\n      }\n\n      a.prototype.clickButton = function (a, e) {\n        var n = this.chart,\n            f = this.buttonOptions[a],\n            k = n.xAxis[0],\n            g = n.scroller && n.scroller.getUnionExtremes() || k || {},\n            h = g.dataMin,\n            l = g.dataMax,\n            y = k && Math.round(Math.min(k.max, C(l, k.max))),\n            m = f.type;\n        g = f._range;\n        var p,\n            t = f.dataGrouping;\n\n        if (null !== h && null !== l) {\n          n.fixedRange = g;\n          this.setSelected(a);\n          t && (this.forcedDataGrouping = !0, b.prototype.setDataGrouping.call(k || {\n            chart: this.chart\n          }, t, !1), this.frozenStates = f.preserveDataGrouping);\n          if (\"month\" === m || \"year\" === m) {\n            if (k) {\n              m = {\n                range: f,\n                max: y,\n                chart: n,\n                dataMin: h,\n                dataMax: l\n              };\n              var u = k.minFromRange.call(m);\n              r(m.newMax) && (y = m.newMax);\n            } else g = f;\n          } else if (g) u = Math.max(y - g, h), y = Math.min(u + g, l);else if (\"ytd\" === m) {\n            if (k) \"undefined\" === typeof l && (h = Number.MAX_VALUE, l = Number.MIN_VALUE, n.series.forEach(function (a) {\n              a = a.xData;\n              h = Math.min(a[0], h);\n              l = Math.max(a[a.length - 1], l);\n            }), e = !1), y = this.getYTDExtremes(l, h, n.time.useUTC), u = p = y.min, y = y.max;else {\n              this.deferredYTDClick = a;\n              return;\n            }\n          } else \"all\" === m && k && (n.navigator && n.navigator.baseSeries[0] && (n.navigator.baseSeries[0].xAxis.options.range = void 0), u = h, y = l);\n          A(u) && (u += f._offsetMin);\n          A(y) && (y += f._offsetMax);\n          this.dropdown && (this.dropdown.selectedIndex = a + 1);\n          if (k) k.setExtremes(u, y, C(e, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: f\n          });else {\n            var z = M(n.options.xAxis)[0];\n            var v = z.range;\n            z.range = g;\n            var x = z.min;\n            z.min = p;\n            d(n, \"load\", function () {\n              z.range = v;\n              z.min = x;\n            });\n          }\n          c(this, \"afterBtnClick\");\n        }\n      };\n\n      a.prototype.setSelected = function (a) {\n        this.selected = this.options.selected = a;\n      };\n\n      a.prototype.init = function (a) {\n        var b = this,\n            e = a.options.rangeSelector,\n            f = e.buttons || b.defaultButtons.slice(),\n            k = e.selected,\n            g = function g() {\n          var a = b.minInput,\n              f = b.maxInput;\n          a && a.blur && c(a, \"blur\");\n          f && f.blur && c(f, \"blur\");\n        };\n\n        b.chart = a;\n        b.options = e;\n        b.buttons = [];\n        b.buttonOptions = f;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(d(a.container, \"mousedown\", g));\n        this.eventsToUnbind.push(d(a, \"resize\", g));\n        f.forEach(b.computeButtonRange);\n        \"undefined\" !== typeof k && f[k] && this.clickButton(k, !1);\n        this.eventsToUnbind.push(d(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && d(a.xAxis[0], \"setExtremes\", function (f) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== f.trigger && \"updatedData\" !== f.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      };\n\n      a.prototype.updateButtonStates = function () {\n        var a = this,\n            b = this.chart,\n            c = this.dropdown,\n            f = b.xAxis[0],\n            k = Math.round(f.max - f.min),\n            e = !f.hasVisibleSeries,\n            d = b.scroller && b.scroller.getUnionExtremes() || f,\n            g = d.dataMin,\n            h = d.dataMax;\n        b = a.getYTDExtremes(h, g, b.time.useUTC);\n        var l = b.min,\n            m = b.max,\n            p = a.selected,\n            t = r(p),\n            u = a.options.allButtonsEnabled,\n            z = a.buttons;\n        a.buttonOptions.forEach(function (b, d) {\n          var n = b._range,\n              q = b.type,\n              w = b.count || 1,\n              y = z[d],\n              r = 0,\n              L = b._offsetMax - b._offsetMin;\n          b = d === p;\n          var P = n > h - g,\n              O = n < f.minRange,\n              N = !1,\n              R = !1;\n          n = n === k;\n          (\"month\" === q || \"year\" === q) && k + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[q] * w - L && k - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[q] * w + L ? n = !0 : \"ytd\" === q ? (n = m - l + L === k, N = !b) : \"all\" === q && (n = f.max - f.min >= h - g, R = !b && t && n);\n          q = !u && (P || O || R || e);\n          w = b && n || n && !t && !N || b && a.frozenStates;\n          q ? r = 3 : w && (t = !0, r = 2);\n          y.state !== r && (y.setState(r), c && (c.options[d + 1].disabled = q, 2 === r && (c.selectedIndex = d + 1)), 0 === r && p === d && a.setSelected());\n        });\n      };\n\n      a.prototype.computeButtonRange = function (a) {\n        var b = a.type,\n            c = a.count || 1,\n            f = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (f[b]) a._range = f[b] * c;else if (\"month\" === b || \"year\" === b) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[b] * c;\n        a._offsetMin = C(a.offsetMin, 0);\n        a._offsetMax = C(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      };\n\n      a.prototype.getInputValue = function (a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        var b = this.chart.options.rangeSelector,\n            c = this.chart.time;\n        return a ? (\"text\" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;\n      };\n\n      a.prototype.setInputValue = function (a, b) {\n        var c = this.options,\n            f = this.chart.time,\n            k = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if (k) {\n          var e = k.getAttribute(\"data-hc-time\");\n          e = A(e) ? Number(e) : void 0;\n          A(b) && (A(e) && k.setAttribute(\"data-hc-time-previous\", e), k.setAttribute(\"data-hc-time\", b), e = b);\n          k.value = f.dateFormat(this.inputTypeFormats[k.type] || c.inputEditDateFormat, e);\n          a && a.attr({\n            text: f.dateFormat(c.inputDateFormat, e)\n          });\n        }\n      };\n\n      a.prototype.setInputExtremes = function (a, b, c) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          var f = this.inputTypeFormats[a.type],\n              k = this.chart.time;\n          f && (b = k.dateFormat(f, b), a.min !== b && (a.min = b), c = k.dateFormat(f, c), a.max !== c && (a.max = c));\n        }\n      };\n\n      a.prototype.showInput = function (a) {\n        var b = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && b && this.inputGroup) {\n          var c = \"text\" === a.type,\n              f = this.inputGroup,\n              k = f.translateX;\n          f = f.translateY;\n          var e = this.options.inputBoxWidth;\n          g(a, {\n            width: c ? b.width + (e ? -2 : 20) + \"px\" : \"auto\",\n            height: c ? b.height - 2 + \"px\" : \"auto\",\n            border: \"2px solid silver\"\n          });\n          c && e ? g(a, {\n            left: k + b.x + \"px\",\n            top: f + \"px\"\n          }) : g(a, {\n            left: Math.min(Math.round(b.x + k - (a.offsetWidth - b.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: f - (a.offsetHeight - b.height) / 2 + \"px\"\n          });\n        }\n      };\n\n      a.prototype.hideInput = function (a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && g(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      };\n\n      a.prototype.defaultInputDateParser = function (a, b, c) {\n        var f = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === f.indexOf(\"T\") && (f += \"T00:00\");\n        if (b) f += \"Z\";else {\n          var k;\n          if (k = v.isSafari) k = f, k = !(6 < k.length && (k.lastIndexOf(\"-\") === k.length - 6 || k.lastIndexOf(\"+\") === k.length - 6));\n          k && (k = new Date(f).getTimezoneOffset() / 60, f += 0 >= k ? \"+\" + m(-k) + \":00\" : \"-\" + m(k) + \":00\");\n        }\n        f = Date.parse(f);\n        r(f) || (a = a.split(\"-\"), f = Date.UTC(J(a[0]), J(a[1]) - 1, J(a[2])));\n        c && b && r(f) && (f += c.getTimezoneOffset(f));\n        return f;\n      };\n\n      a.prototype.drawInput = function (a) {\n        function b() {\n          var b = d.getInputValue(a),\n              f = c.xAxis[0],\n              k = c.scroller && c.scroller.xAxis ? c.scroller.xAxis : f,\n              e = k.dataMin;\n          k = k.dataMax;\n          var g = d.maxInput,\n              h = d.minInput;\n          b !== Number(u.getAttribute(\"data-hc-time-previous\")) && r(b) && (u.setAttribute(\"data-hc-time-previous\", b), t && g && r(e) ? b > Number(g.getAttribute(\"data-hc-time\")) ? b = void 0 : b < e && (b = e) : h && r(k) && (b < Number(h.getAttribute(\"data-hc-time\")) ? b = void 0 : b > k && (b = k)), \"undefined\" !== typeof b && f.setExtremes(t ? b : f.min, t ? f.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n\n        var c = this.chart,\n            f = this.div,\n            k = this.inputGroup,\n            d = this,\n            n = c.renderer.style || {},\n            l = c.renderer,\n            m = c.options.rangeSelector,\n            t = \"min\" === a,\n            P = x.lang[t ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\";\n        P = l.label(P, 0).addClass(\"highcharts-range-label\").attr({\n          padding: P ? 2 : 0,\n          height: P ? m.inputBoxHeight : 0\n        }).add(k);\n        l = l.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: m.inputBoxWidth,\n          height: m.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          d.showInput(a);\n          d[a + \"Input\"].focus();\n        });\n        c.styledMode || l.attr({\n          stroke: m.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        l.add(k);\n        var u = p(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, f);\n        u.setAttribute(\"type\", h(m.inputDateFormat || \"%b %e, %Y\"));\n        c.styledMode || (P.css(F(n, m.labelStyle)), l.css(F({\n          color: \"#333333\"\n        }, n, m.inputStyle)), g(u, e({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: n.fontSize,\n          fontFamily: n.fontFamily,\n          top: \"-9999em\"\n        }, m.inputStyle)));\n\n        u.onfocus = function () {\n          d.showInput(a);\n        };\n\n        u.onblur = function () {\n          u === v.doc.activeElement && b();\n          d.hideInput(a);\n          d.setInputValue(a);\n          u.blur();\n        };\n\n        var z = !1;\n\n        u.onchange = function () {\n          z || (b(), d.hideInput(a), u.blur());\n        };\n\n        u.onkeypress = function (a) {\n          13 === a.keyCode && b();\n        };\n\n        u.onkeydown = function (a) {\n          z = !0;\n          38 !== a.keyCode && 40 !== a.keyCode || b();\n        };\n\n        u.onkeyup = function () {\n          z = !1;\n        };\n\n        return {\n          dateBox: l,\n          input: u,\n          label: P\n        };\n      };\n\n      a.prototype.getPosition = function () {\n        var a = this.chart,\n            b = a.options.rangeSelector;\n        a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      };\n\n      a.prototype.getYTDExtremes = function (a, b, c) {\n        var f = this.chart.time,\n            k = new f.Date(a),\n            e = f.get(\"FullYear\", k);\n        c = c ? f.Date.UTC(e, 0, 1) : +new f.Date(e, 0, 1);\n        b = Math.max(b, c);\n        k = k.getTime();\n        return {\n          max: Math.min(a || k, k),\n          min: b\n        };\n      };\n\n      a.prototype.render = function (a, b) {\n        var c = this.chart,\n            f = c.renderer,\n            k = c.container,\n            e = c.options,\n            d = e.rangeSelector,\n            g = C(e.chart.style && e.chart.style.zIndex, 0) + 1;\n        e = d.inputEnabled;\n\n        if (!1 !== d.enabled) {\n          this.rendered || (this.group = f.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = p(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: g\n          }), this.buttonOptions.length && this.renderButtons(), k.parentNode && k.parentNode.insertBefore(this.div, k), e && (this.inputGroup = f.g(\"input-group\").add(this.group), f = this.drawInput(\"min\"), this.minDateBox = f.dateBox, this.minLabel = f.label, this.minInput = f.input, f = this.drawInput(\"max\"), this.maxDateBox = f.dateBox, this.maxLabel = f.label, this.maxInput = f.input));\n\n          if (e && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, A(a.dataMin) && A(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - c), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + c, a.dataMax)), this.inputGroup)) {\n            var h = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {\n              if (a) {\n                var b = a.getBBox().width;\n                b && (a.attr({\n                  x: h\n                }), h += b + d.inputSpacing);\n              }\n            });\n          }\n\n          this.alignElements();\n          this.rendered = !0;\n        }\n      };\n\n      a.prototype.renderButtons = function () {\n        var a = this,\n            b = this.buttons,\n            e = this.options,\n            f = x.lang,\n            k = this.chart.renderer,\n            g = F(e.buttonTheme),\n            h = g && g.states,\n            l = g.width || 28;\n        delete g.width;\n        delete g.states;\n        this.buttonGroup = k.g(\"range-selector-buttons\").add(this.group);\n        var m = this.dropdown = p(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        d(m, \"touchstart\", function () {\n          m.style.fontSize = \"16px\";\n        });\n        [[v.isMS ? \"mouseover\" : \"mouseenter\"], [v.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(function (f) {\n          var k = f[0],\n              e = f[1];\n          d(m, k, function () {\n            var f = b[a.currentButtonIndex()];\n            f && c(f.element, e || k);\n          });\n        });\n        this.zoomText = k.label(f && f.rangeSelectorZoom || \"\", 0).attr({\n          padding: e.buttonTheme.padding,\n          height: e.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(e.labelStyle), g[\"stroke-width\"] = C(g[\"stroke-width\"], 0));\n        p(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, m);\n        this.buttonOptions.forEach(function (c, f) {\n          p(\"option\", {\n            textContent: c.title || c.text\n          }, void 0, m);\n          b[f] = k.button(c.text, 0, 0, function (b) {\n            var k = c.events && c.events.click,\n                e;\n            k && (e = k.call(c, b));\n            !1 !== e && a.clickButton(f);\n            a.isActive = !0;\n          }, g, h && h.hover, h && h.select, h && h.disabled).attr({\n            \"text-align\": \"center\",\n            width: l\n          }).add(a.buttonGroup);\n          c.title && b[f].attr(\"title\", c.title);\n        });\n      };\n\n      a.prototype.alignElements = function () {\n        var a = this,\n            b = this.buttonGroup,\n            c = this.buttons,\n            f = this.chart,\n            k = this.group,\n            e = this.inputGroup,\n            d = this.options,\n            g = this.zoomText,\n            h = f.options,\n            l = h.exporting && !1 !== h.exporting.enabled && h.navigation && h.navigation.buttonOptions;\n        h = d.buttonPosition;\n\n        var m = d.inputPosition,\n            r = d.verticalAlign,\n            p = function p(b, c) {\n          return l && a.titleCollision(f) && \"top\" === r && \"right\" === c.align && c.y - b.getBBox().height - 12 < (l.y || 0) + (l.height || 0) + f.spacing[0] ? -40 : 0;\n        },\n            t = f.plotLeft;\n\n        if (k && h && m) {\n          var u = h.x - f.spacing[3];\n\n          if (b) {\n            this.positionButtons();\n\n            if (!this.initialButtonGroupWidth) {\n              var z = 0;\n              g && (z += g.getBBox().width + 5);\n              c.forEach(function (a, b) {\n                z += a.width;\n                b !== c.length - 1 && (z += d.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = z;\n            }\n\n            t -= f.spacing[3];\n            this.updateButtonStates();\n            g = p(b, h);\n            this.alignButtonGroup(g);\n            k.placed = b.placed = f.hasLoaded;\n          }\n\n          b = 0;\n          e && (b = p(e, m), \"left\" === m.align ? u = t : \"right\" === m.align && (u = -Math.max(f.axisOffset[1], -b)), e.align({\n            y: m.y,\n            width: e.getBBox().width,\n            align: m.align,\n            x: m.x + u - 2\n          }, !0, f.spacingBox), e.placed = f.hasLoaded);\n          this.handleCollision(b);\n          k.align({\n            verticalAlign: r\n          }, !0, f.spacingBox);\n          e = k.alignAttr.translateY;\n          b = k.getBBox().height + 20;\n          p = 0;\n          \"bottom\" === r && (p = (p = f.legend && f.legend.options) && \"bottom\" === p.verticalAlign && p.enabled && !p.floating ? f.legend.legendHeight + C(p.margin, 10) : 0, b = b + p - 20, p = e - b - (d.floating ? 0 : d.y) - (f.titleOffset ? f.titleOffset[2] : 0) - 10);\n          if (\"top\" === r) d.floating && (p = 0), f.titleOffset && f.titleOffset[0] && (p = f.titleOffset[0]), p += f.margin[0] - f.spacing[0] || 0;else if (\"middle\" === r) if (m.y === h.y) p = e;else if (m.y || h.y) p = 0 > m.y || 0 > h.y ? p - Math.min(m.y, h.y) : e - b;\n          k.translate(d.x, d.y + Math.floor(p));\n          h = this.minInput;\n          m = this.maxInput;\n          e = this.dropdown;\n          d.inputEnabled && h && m && (h.style.marginTop = k.translateY + \"px\", m.style.marginTop = k.translateY + \"px\");\n          e && (e.style.marginTop = k.translateY + \"px\");\n        }\n      };\n\n      a.prototype.alignButtonGroup = function (a, b) {\n        var c = this.chart,\n            f = this.buttonGroup,\n            k = this.options.buttonPosition,\n            e = c.plotLeft - c.spacing[3],\n            d = k.x - c.spacing[3];\n        \"right\" === k.align ? d += a - e : \"center\" === k.align && (d -= e / 2);\n        f && f.align({\n          y: k.y,\n          width: C(b, this.initialButtonGroupWidth),\n          align: k.align,\n          x: d\n        }, !0, c.spacingBox);\n      };\n\n      a.prototype.positionButtons = function () {\n        var a = this.buttons,\n            b = this.chart,\n            c = this.options,\n            f = this.zoomText,\n            k = b.hasLoaded ? \"animate\" : \"attr\",\n            e = c.buttonPosition,\n            d = b.plotLeft,\n            g = d;\n        f && \"hidden\" !== f.visibility && (f[k]({\n          x: C(d + e.x, d)\n        }), g += e.x + f.getBBox().width + 5);\n        this.buttonOptions.forEach(function (b, f) {\n          if (\"hidden\" !== a[f].visibility) a[f][k]({\n            x: g\n          }), g += a[f].width + c.buttonSpacing;else a[f][k]({\n            x: d\n          });\n        });\n      };\n\n      a.prototype.handleCollision = function (a) {\n        var b = this,\n            c = this.chart,\n            f = this.buttonGroup,\n            k = this.inputGroup,\n            e = this.options,\n            d = e.buttonPosition,\n            g = e.dropdown,\n            h = e.inputPosition;\n\n        e = function e() {\n          var a = 0;\n          b.buttons.forEach(function (b) {\n            b = b.getBBox();\n            b.width > a && (a = b.width);\n          });\n          return a;\n        };\n\n        var n = function n(b) {\n          if (k && f) {\n            var c = k.alignAttr.translateX + k.alignOptions.x - a + k.getBBox().x + 2,\n                e = k.alignOptions.width,\n                g = f.alignAttr.translateX + f.getBBox().x;\n            return g + b > c && c + e > g && d.y < h.y + k.getBBox().height;\n          }\n\n          return !1;\n        },\n            l = function l() {\n          k && f && k.attr({\n            translateX: k.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),\n            translateY: k.alignAttr.translateY + f.getBBox().height + 10\n          });\n        };\n\n        if (f) {\n          if (\"always\" === g) {\n            this.collapseButtons(a);\n            n(e()) && l();\n            return;\n          }\n\n          \"never\" === g && this.expandButtons();\n        }\n\n        k && f ? h.align === d.align || n(this.initialButtonGroupWidth + 20) ? \"responsive\" === g ? (this.collapseButtons(a), n(e()) && l()) : l() : \"responsive\" === g && this.expandButtons() : f && \"responsive\" === g && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      };\n\n      a.prototype.collapseButtons = function (a) {\n        var b = this.buttons,\n            c = this.buttonOptions,\n            f = this.chart,\n            e = this.dropdown,\n            d = this.options,\n            g = this.zoomText,\n            h = f.userOptions.rangeSelector && f.userOptions.rangeSelector.buttonTheme || {},\n            n = function n(a) {\n          return {\n            text: a ? a + \" \\u25BE\" : \"\\u25BE\",\n            width: \"auto\",\n            paddingLeft: C(d.buttonTheme.paddingLeft, h.padding, 8),\n            paddingRight: C(d.buttonTheme.paddingRight, h.padding, 8)\n          };\n        };\n\n        g && g.hide();\n        var l = !1;\n        c.forEach(function (a, c) {\n          c = b[c];\n          2 !== c.state ? c.hide() : (c.show(), c.attr(n(a.text)), l = !0);\n        });\n        l || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(n(this.zoomText && this.zoomText.textStr)));\n        c = d.buttonPosition.align;\n        this.positionButtons();\n        \"right\" !== c && \"center\" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      };\n\n      a.prototype.expandButtons = function () {\n        var a = this.buttons,\n            b = this.buttonOptions,\n            c = this.options,\n            f = this.zoomText;\n        this.hideDropdown();\n        f && f.show();\n        b.forEach(function (b, f) {\n          f = a[f];\n          f.show();\n          f.attr({\n            text: b.text,\n            width: c.buttonTheme.width || 28,\n            paddingLeft: C(c.buttonTheme.paddingLeft, \"unset\"),\n            paddingRight: C(c.buttonTheme.paddingRight, \"unset\")\n          });\n          2 > f.state && f.setState(0);\n        });\n        this.positionButtons();\n      };\n\n      a.prototype.currentButtonIndex = function () {\n        var a = this.dropdown;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      };\n\n      a.prototype.showDropdown = function () {\n        var a = this.buttonGroup,\n            b = this.buttons,\n            c = this.chart,\n            f = this.dropdown;\n\n        if (a && f) {\n          var e = a.translateX;\n          a = a.translateY;\n          b = b[this.currentButtonIndex()].getBBox();\n          g(f, {\n            left: c.plotLeft + e + \"px\",\n            top: a + .5 + \"px\",\n            width: b.width + \"px\",\n            height: b.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      };\n\n      a.prototype.hideDropdown = function () {\n        var a = this.dropdown;\n        a && (g(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      };\n\n      a.prototype.getHeight = function () {\n        var a = this.options,\n            b = this.group,\n            c = a.y,\n            f = a.buttonPosition.y,\n            e = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = b ? b.getBBox(!0).height + 13 + c : 0;\n        b = Math.min(e, f);\n        if (0 > e && 0 > f || 0 < e && 0 < f) a += Math.abs(b);\n        return a;\n      };\n\n      a.prototype.titleCollision = function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      };\n\n      a.prototype.update = function (a) {\n        var b = this.chart;\n        F(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        this.render();\n      };\n\n      a.prototype.destroy = function () {\n        var b = this,\n            c = b.minInput,\n            e = b.maxInput;\n        b.eventsToUnbind && (b.eventsToUnbind.forEach(function (a) {\n          return a();\n        }), b.eventsToUnbind = void 0);\n        D(b.buttons);\n        c && (c.onfocus = c.onblur = c.onchange = null);\n        e && (e.onfocus = e.onblur = e.onchange = null);\n        G(b, function (c, e) {\n          c && \"chart\" !== e && (c instanceof B ? c.destroy() : c instanceof window.HTMLElement && H(c));\n          c !== a.prototype[e] && (b[e] = null);\n        }, this);\n      };\n\n      return a;\n    }();\n\n    E.prototype.defaultButtons = [{\n      type: \"month\",\n      count: 1,\n      text: \"1m\",\n      title: \"View 1 month\"\n    }, {\n      type: \"month\",\n      count: 3,\n      text: \"3m\",\n      title: \"View 3 months\"\n    }, {\n      type: \"month\",\n      count: 6,\n      text: \"6m\",\n      title: \"View 6 months\"\n    }, {\n      type: \"ytd\",\n      text: \"YTD\",\n      title: \"View year to date\"\n    }, {\n      type: \"year\",\n      count: 1,\n      text: \"1y\",\n      title: \"View 1 year\"\n    }, {\n      type: \"all\",\n      text: \"All\",\n      title: \"View all\"\n    }];\n    E.prototype.inputTypeFormats = {\n      \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n      date: \"%Y-%m-%d\",\n      time: \"%H:%M:%S\"\n    };\n\n    b.prototype.minFromRange = function () {\n      var a = this.range,\n          b = a.type,\n          c = this.max,\n          e = this.chart.time,\n          f = function f(a, c) {\n        var f = \"year\" === b ? \"FullYear\" : \"Month\",\n            k = new e.Date(a),\n            d = e.get(f, k);\n        e.set(f, k, d + c);\n        d === e.get(f, k) && e.set(\"Date\", k, 0);\n        return k.getTime() - a;\n      };\n\n      if (r(a)) {\n        var k = c - a;\n        var d = a;\n      } else k = c + f(c, -a.count), this.chart && (this.chart.fixedRange = c - k);\n\n      var g = C(this.dataMin, Number.MIN_VALUE);\n      r(k) || (k = g);\n      k <= g && (k = g, \"undefined\" === typeof d && (d = f(k, a.count)), this.newMax = Math.min(k + d, this.dataMax));\n      r(c) || (k = void 0);\n      return k;\n    };\n\n    if (!v.RangeSelector) {\n      var K = [],\n          I = function I(b) {\n        function c() {\n          g && (e = b.xAxis[0].getExtremes(), f = b.legend, h = g && g.options.verticalAlign, r(e.min) && g.render(e.min, e.max), f.display && \"top\" === h && h === f.options.verticalAlign && (k = F(b.spacingBox), k.y = \"vertical\" === f.options.layout ? b.plotTop : k.y + g.getHeight(), f.group.placed = !1, f.align(k)));\n        }\n\n        var e,\n            g = b.rangeSelector,\n            f,\n            k,\n            h;\n        g && (a(K, function (a) {\n          return a[0] === b;\n        }) || K.push([b, [d(b.xAxis[0], \"afterSetExtremes\", function (a) {\n          g && g.render(a.min, a.max);\n        }), d(b, \"redraw\", c)]]), c());\n      };\n\n      d(t, \"afterGetContainer\", function () {\n        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new E(this));\n      });\n      d(t, \"beforeRender\", function () {\n        var a = this.axes,\n            b = this.rangeSelector;\n        b && (r(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n      });\n      d(t, \"update\", function (a) {\n        var b = a.options.rangeSelector;\n        a = this.rangeSelector;\n        var c = this.extraBottomMargin,\n            e = this.extraTopMargin;\n        b && b.enabled && !A(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new E(this));\n        this.extraTopMargin = this.extraBottomMargin = !1;\n        a && (I(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== c || this.extraTopMargin !== e) && (this.isDirtyBox = !0);\n      });\n      d(t, \"render\", function () {\n        var a = this.rangeSelector;\n        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n      });\n      d(t, \"getMargins\", function () {\n        var a = this.rangeSelector;\n        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n      });\n      t.prototype.callbacks.push(I);\n      d(t, \"destroy\", function () {\n        for (var a = 0; a < K.length; a++) {\n          var b = K[a];\n\n          if (b[0] === this) {\n            b[1].forEach(function (a) {\n              return a();\n            });\n            K.splice(a, 1);\n            break;\n          }\n        }\n      });\n      v.RangeSelector = E;\n    }\n\n    return E;\n  });\n  J(b, \"Core/Axis/NavigatorAxis.js\", [b[\"Core/Globals.js\"], b[\"Core/Utilities.js\"]], function (b, t) {\n    var v = b.isTouchDevice,\n        u = t.addEvent,\n        B = t.correctFloat,\n        l = t.defined,\n        h = t.isNumber,\n        x = t.pick,\n        d = function () {\n      function b(b) {\n        this.axis = b;\n      }\n\n      b.prototype.destroy = function () {\n        this.axis = void 0;\n      };\n\n      b.prototype.toFixedRange = function (b, d, p, t) {\n        var e = this.axis,\n            a = e.chart;\n        a = a && a.fixedRange;\n        var c = (e.pointRange || 0) / 2;\n        b = x(p, e.translate(b, !0, !e.horiz));\n        d = x(t, e.translate(d, !0, !e.horiz));\n        e = a && (d - b) / a;\n        l(p) || (b = B(b + c));\n        l(t) || (d = B(d - c));\n        .7 < e && 1.3 > e && (t ? b = d - a : d = b + a);\n        h(b) && h(d) || (b = d = void 0);\n        return {\n          min: b,\n          max: d\n        };\n      };\n\n      return b;\n    }();\n\n    return function () {\n      function b() {}\n\n      b.compose = function (b) {\n        b.keepProps.push(\"navigatorAxis\");\n        u(b, \"init\", function () {\n          this.navigatorAxis || (this.navigatorAxis = new d(this));\n        });\n        u(b, \"zoom\", function (b) {\n          var d = this.chart.options,\n              g = d.navigator,\n              e = this.navigatorAxis,\n              a = d.chart.pinchType,\n              c = d.rangeSelector;\n          d = d.chart.zoomType;\n          this.isXAxis && (g && g.enabled || c && c.enabled) && (\"y\" === d ? b.zoomed = !1 : (!v && \"xy\" === d || v && \"xy\" === a) && this.options.range && (g = e.previousZoom, l(b.newMin) ? e.previousZoom = [this.min, this.max] : g && (b.newMin = g[0], b.newMax = g[1], e.previousZoom = void 0)));\n          \"undefined\" !== typeof b.zoomed && b.preventDefault();\n        });\n      };\n\n      b.AdditionsClass = d;\n      return b;\n    }();\n  });\n  J(b, \"Core/Navigator.js\", [b[\"Core/Axis/Axis.js\"], b[\"Core/Chart/Chart.js\"], b[\"Core/Color/Color.js\"], b[\"Core/Globals.js\"], b[\"Core/Axis/NavigatorAxis.js\"], b[\"Core/DefaultOptions.js\"], b[\"Core/Renderer/RendererRegistry.js\"], b[\"Core/Scrollbar.js\"], b[\"Core/Series/Series.js\"], b[\"Core/Series/SeriesRegistry.js\"], b[\"Core/Utilities.js\"]], function (b, t, v, u, B, l, h, x, d, p, g) {\n    v = v.parse;\n\n    var A = u.hasTouch,\n        D = u.isTouchDevice,\n        H = l.defaultOptions,\n        e = g.addEvent,\n        a = g.clamp,\n        c = g.correctFloat,\n        r = g.defined,\n        F = g.destroyObjectProperties,\n        G = g.erase,\n        m = g.extend,\n        C = g.find,\n        J = g.isArray,\n        M = g.isNumber,\n        E = g.merge,\n        K = g.pick,\n        I = g.removeEvent,\n        z = g.splat,\n        n = function n(a) {\n      for (var b = [], c = 1; c < arguments.length; c++) {\n        b[c - 1] = arguments[c];\n      }\n\n      b = [].filter.call(b, M);\n      if (b.length) return Math[a].apply(0, b);\n    };\n\n    l = \"undefined\" === typeof p.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    m(H, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: v(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: l,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            firstAnchor: \"firstPoint\",\n            anchor: \"middle\",\n            lastAnchor: \"lastPoint\",\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    h.getRendererType().prototype.symbols[\"navigator-handle\"] = function (a, b, c, e, d) {\n      a = (d && d.width || 0) / 2;\n      b = Math.round(a / 3) + .5;\n      d = d && d.height || 0;\n      return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, d + .5], [\"L\", -a - 1, d + .5], [\"L\", -a - 1, .5], [\"M\", -b, 4], [\"L\", -b, d - 3], [\"M\", b - 1, 4], [\"L\", b - 1, d - 3]];\n    };\n\n    var y = function () {\n      function d(a) {\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.init(a);\n      }\n\n      d.prototype.drawHandle = function (a, b, c, e) {\n        var f = this.navigatorOptions.handles.height;\n        this.handles[b][e](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - f)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - f / 2 - 1)\n        });\n      };\n\n      d.prototype.drawOutline = function (a, b, c, e) {\n        var f = this.navigatorOptions.maskInside,\n            d = this.outline.strokeWidth(),\n            k = d / 2,\n            g = d % 2 / 2;\n        d = this.outlineHeight;\n        var h = this.scrollbarHeight || 0,\n            l = this.size,\n            n = this.left - h,\n            m = this.top;\n        c ? (n -= k, c = m + b + g, b = m + a + g, g = [[\"M\", n + d, m - h - g], [\"L\", n + d, c], [\"L\", n, c], [\"L\", n, b], [\"L\", n + d, b], [\"L\", n + d, m + l + h]], f && g.push([\"M\", n + d, c - k], [\"L\", n + d, b + k])) : (a += n + h - g, b += n + h - g, m += k, g = [[\"M\", n, m], [\"L\", a, m], [\"L\", a, m + d], [\"L\", b, m + d], [\"L\", b, m], [\"L\", n + l + 2 * h, m]], f && g.push([\"M\", a - k, m], [\"L\", b + k, m]));\n        this.outline[e]({\n          d: g\n        });\n      };\n\n      d.prototype.drawMasks = function (a, b, c, e) {\n        var f = this.left,\n            d = this.top,\n            k = this.height;\n\n        if (c) {\n          var g = [f, f, f];\n          var h = [d, d + a, d + b];\n          var l = [k, k, k];\n          var n = [a, b - a, this.size - b];\n        } else g = [f, f + a, f + b], h = [d, d, d], l = [a, b - a, this.size - b], n = [k, k, k];\n\n        this.shades.forEach(function (a, b) {\n          a[e]({\n            x: g[b],\n            y: h[b],\n            width: l[b],\n            height: n[b]\n          });\n        });\n      };\n\n      d.prototype.renderElements = function () {\n        var a = this,\n            b = a.navigatorOptions,\n            c = b.maskInside,\n            e = a.chart,\n            d = e.renderer,\n            g,\n            h = {\n          cursor: e.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = g = d.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!c, c, !c].forEach(function (c, f) {\n          a.shades[f] = d.rect().addClass(\"highcharts-navigator-mask\" + (1 === f ? \"-inside\" : \"-outside\")).add(g);\n          e.styledMode || a.shades[f].attr({\n            fill: c ? b.maskFill : \"rgba(0,0,0,0)\"\n          }).css(1 === f && h);\n        });\n        a.outline = d.path().addClass(\"highcharts-navigator-outline\").add(g);\n        e.styledMode || a.outline.attr({\n          \"stroke-width\": b.outlineWidth,\n          stroke: b.outlineColor\n        });\n        b.handles.enabled && [0, 1].forEach(function (c) {\n          b.handles.inverted = e.inverted;\n          a.handles[c] = d.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);\n          a.handles[c].attr({\n            zIndex: 7 - c\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(g);\n\n          if (!e.styledMode) {\n            var f = b.handles;\n            a.handles[c].attr({\n              fill: f.backgroundColor,\n              stroke: f.borderColor,\n              \"stroke-width\": f.lineWidth\n            }).css(h);\n          }\n        });\n      };\n\n      d.prototype.update = function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        E(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      };\n\n      d.prototype.render = function (b, e, d, g) {\n        var f = this.chart,\n            k = this.scrollbarHeight,\n            h,\n            l = this.xAxis,\n            n = l.pointRange || 0;\n        var m = l.navigatorAxis.fake ? f.xAxis[0] : l;\n        var q = this.navigatorEnabled,\n            w,\n            p = this.rendered;\n        var t = f.inverted;\n        var u = f.xAxis[0].minRange,\n            v = f.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || r(d)) {\n          b = c(b - n / 2);\n          e = c(e + n / 2);\n          if (!M(b) || !M(e)) if (p) d = 0, g = K(l.width, m.width);else return;\n          this.left = K(l.left, f.plotLeft + k + (t ? f.plotWidth : 0));\n          this.size = w = h = K(l.len, (t ? f.plotHeight : f.plotWidth) - 2 * k);\n          f = t ? k : h + 2 * k;\n          d = K(d, l.toPixels(b, !0));\n          g = K(g, l.toPixels(e, !0));\n          M(d) && Infinity !== Math.abs(d) || (d = 0, g = f);\n          b = l.toValue(d, !0);\n          e = l.toValue(g, !0);\n          var x = Math.abs(c(e - b));\n          x < u ? this.grabbedLeft ? d = l.toPixels(e - u - n, !0) : this.grabbedRight && (g = l.toPixels(b + u + n, !0)) : r(v) && c(x - n) > v && (this.grabbedLeft ? d = l.toPixels(e - v - n, !0) : this.grabbedRight && (g = l.toPixels(b + v + n, !0)));\n          this.zoomedMax = a(Math.max(d, g), 0, w);\n          this.zoomedMin = a(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(d, g), 0, w);\n          this.range = this.zoomedMax - this.zoomedMin;\n          w = Math.round(this.zoomedMax);\n          d = Math.round(this.zoomedMin);\n          q && (this.navigatorGroup.attr({\n            visibility: \"visible\"\n          }), p = p && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(d, w, t, p), this.drawOutline(d, w, t, p), this.navigatorOptions.handles.enabled && (this.drawHandle(d, 0, t, p), this.drawHandle(w, 1, t, p)));\n          this.scrollbar && (t ? (t = this.top - k, m = this.left - k + (q || !m.opposite ? 0 : (m.titleOffset || 0) + m.axisTitleMargin), k = h + 2 * k) : (t = this.top + (q ? this.height : -k), m = this.left - k), this.scrollbar.position(m, t, f, k), this.scrollbar.setRange(this.zoomedMin / (h || 1), this.zoomedMax / (h || 1)));\n          this.rendered = !0;\n        }\n      };\n\n      d.prototype.addMouseEvents = function () {\n        var a = this,\n            b = a.chart,\n            c = b.container,\n            d = [],\n            g,\n            h;\n\n        a.mouseMoveHandler = g = function g(b) {\n          a.onMouseMove(b);\n        };\n\n        a.mouseUpHandler = h = function h(b) {\n          a.onMouseUp(b);\n        };\n\n        d = a.getPartsEvents(\"mousedown\");\n        d.push(e(b.renderTo, \"mousemove\", g), e(c.ownerDocument, \"mouseup\", h));\n        A && (d.push(e(b.renderTo, \"touchmove\", g), e(c.ownerDocument, \"touchend\", h)), d.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = d;\n        a.series && a.series[0] && d.push(e(a.series[0].xAxis, \"foundExtremes\", function () {\n          b.navigator.modifyNavigatorAxisExtremes();\n        }));\n      };\n\n      d.prototype.getPartsEvents = function (a) {\n        var b = this,\n            c = [];\n        [\"shades\", \"handles\"].forEach(function (f) {\n          b[f].forEach(function (d, k) {\n            c.push(e(d.element, a, function (a) {\n              b[f + \"Mousedown\"](a, k);\n            }));\n          });\n        });\n        return c;\n      };\n\n      d.prototype.shadesMousedown = function (a, b) {\n        a = this.chart.pointer.normalize(a);\n        var c = this.chart,\n            f = this.xAxis,\n            d = this.zoomedMin,\n            e = this.left,\n            k = this.size,\n            g = this.range,\n            h = a.chartX;\n        c.inverted && (h = a.chartY, e = this.top);\n        if (1 === b) this.grabbedCenter = h, this.fixedWidth = g, this.dragOffset = h - d;else {\n          a = h - e - g / 2;\n          if (0 === b) a = Math.max(0, a);else if (2 === b && a + g >= k) if (a = k - g, this.reversedExtremes) {\n            a -= g;\n            var l = this.getUnionExtremes().dataMin;\n          } else var n = this.getUnionExtremes().dataMax;\n          a !== d && (this.fixedWidth = g, b = f.navigatorAxis.toFixedRange(a, a + g, l, n), r(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {\n            trigger: \"navigator\"\n          }));\n        }\n      };\n\n      d.prototype.handlesMousedown = function (a, b) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var c = a.xAxis[0],\n            f = this.reversedExtremes;\n        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = f ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = f ? c.max : c.min);\n        a.fixedRange = null;\n      };\n\n      d.prototype.onMouseMove = function (a) {\n        var b = this,\n            c = b.chart,\n            f = b.left,\n            d = b.navigatorSize,\n            e = b.range,\n            g = b.dragOffset,\n            h = c.inverted;\n        a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, h && (f = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - f, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - f)) : b.grabbedCenter && (b.hasDragged = !0, c < g ? c = g : c > d + g - e && (c = d + g - e), b.render(0, 0, c - g, c - g + e)), b.hasDragged && b.scrollbar && K(b.scrollbar.options.liveRedraw, u.svg && !D && !this.chart.isBoosting) && (a.DOMType = a.type, setTimeout(function () {\n          b.onMouseUp(a);\n        }, 0)));\n      };\n\n      d.prototype.onMouseUp = function (a) {\n        var b = this.chart,\n            c = this.xAxis,\n            f = this.scrollbar,\n            d = a.DOMEvent || a,\n            e = b.inverted,\n            g = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n\n        if (this.hasDragged && (!f || !f.hasDragged) || \"scrollbar\" === a.trigger) {\n          f = this.getUnionExtremes();\n          if (this.zoomedMin === this.otherHandlePos) var h = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var l = this.fixedExtreme;\n          this.zoomedMax === this.size && (l = this.reversedExtremes ? f.dataMin : f.dataMax);\n          0 === this.zoomedMin && (h = this.reversedExtremes ? f.dataMax : f.dataMin);\n          c = c.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, h, l);\n          r(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {\n            trigger: \"navigator\",\n            triggerOp: \"navigator-drag\",\n            DOMEvent: d\n          });\n        }\n\n        \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && M(this.zoomedMin) && M(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, e, g), this.outline && this.drawOutline(b, a, e, g), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, e, g), this.drawHandle(a, 1, e, g)));\n      };\n\n      d.prototype.removeEvents = function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      };\n\n      d.prototype.removeBaseSeriesEvents = function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          I(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && I(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      };\n\n      d.prototype.init = function (a) {\n        var c = a.options,\n            f = c.navigator,\n            d = f.enabled,\n            g = c.scrollbar,\n            h = g.enabled;\n        c = d ? f.height : 0;\n        var l = h ? g.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = a;\n        this.setBaseSeries();\n        this.height = c;\n        this.scrollbarHeight = l;\n        this.scrollbarEnabled = h;\n        this.navigatorEnabled = d;\n        this.navigatorOptions = f;\n        this.scrollbarOptions = g;\n        this.outlineHeight = c + l;\n        this.opposite = K(f.opposite, !(d || !a.inverted));\n        var m = this;\n        d = m.baseSeries;\n        g = a.xAxis.length;\n        h = a.yAxis.length;\n        var q = d && d[0] && d[0].xAxis || a.xAxis[0] || {\n          options: {}\n        };\n        a.isDirtyBox = !0;\n        m.navigatorEnabled ? (m.xAxis = new b(a, E({\n          breaks: q.options.breaks,\n          ordinal: q.options.ordinal\n        }, f.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: g,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          offsets: [l, 0, -l, 0],\n          width: c\n        } : {\n          offsets: [0, -l, 0, l],\n          height: c\n        })), m.yAxis = new b(a, E(f.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: h,\n          isInternal: !0,\n          reversed: K(f.yAxis && f.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, a.inverted ? {\n          width: c\n        } : {\n          height: c\n        })), d || f.series.data ? m.updateNavigatorSeries(!1) : 0 === a.series.length && (m.unbindRedraw = e(a, \"beforeRedraw\", function () {\n          0 < a.series.length && !m.series && (m.setBaseSeries(), m.unbindRedraw());\n        })), m.reversedExtremes = a.inverted && !m.xAxis.reversed || !a.inverted && m.xAxis.reversed, m.renderElements(), m.addMouseEvents()) : (m.xAxis = {\n          chart: a,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function translate(b, c) {\n            var f = a.xAxis[0],\n                d = f.getExtremes(),\n                e = f.len - 2 * l,\n                g = n(\"min\", f.options.min, d.dataMin);\n            f = n(\"max\", f.options.max, d.dataMax) - g;\n            return c ? b * f / e + g : e * (b - g) / f;\n          },\n          toPixels: function toPixels(a) {\n            return this.translate(a);\n          },\n          toValue: function toValue(a) {\n            return this.translate(a, !0);\n          }\n        }, m.xAxis.navigatorAxis.axis = m.xAxis, m.xAxis.navigatorAxis.toFixedRange = B.AdditionsClass.prototype.toFixedRange.bind(m.xAxis.navigatorAxis));\n        a.options.scrollbar.enabled && (a.scrollbar = m.scrollbar = new x(a.renderer, E(a.options.scrollbar, {\n          margin: m.navigatorEnabled ? 0 : 10,\n          vertical: a.inverted\n        }), a), e(m.scrollbar, \"changed\", function (a) {\n          var b = m.size,\n              c = b * this.to;\n          b *= this.from;\n          m.hasDragged = m.scrollbar.hasDragged;\n          m.render(0, 0, b, c);\n          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {\n            m.onMouseUp(a);\n          });\n        }));\n        m.addBaseSeriesEvents();\n        m.addChartEvents();\n      };\n\n      d.prototype.getUnionExtremes = function (a) {\n        var b = this.chart.xAxis[0],\n            c = this.xAxis,\n            f = c.options,\n            d = b.options,\n            e;\n        a && null === b.dataMin || (e = {\n          dataMin: K(f && f.min, n(\"min\", d.min, b.dataMin, c.dataMin, c.min)),\n          dataMax: K(f && f.max, n(\"max\", d.max, b.dataMax, c.dataMax, c.max))\n        });\n        return e;\n      };\n\n      d.prototype.setBaseSeries = function (a, b) {\n        var c = this.chart,\n            f = this.baseSeries = [];\n        a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? C(c.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (c.series || []).forEach(function (b, c) {\n          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || f.push(b);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);\n      };\n\n      d.prototype.updateNavigatorSeries = function (a, b) {\n        var c = this,\n            f = c.chart,\n            d = c.baseSeries,\n            e,\n            g,\n            k = c.navigatorOptions.series,\n            h,\n            l = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: void 0,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            n = c.series = (c.series || []).filter(function (a) {\n          var b = a.baseSeries;\n          return 0 > d.indexOf(b) ? (b && (I(b, \"updatedData\", c.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        d && d.length && d.forEach(function (a) {\n          var q = a.navigatorSeries,\n              p = m({\n            color: a.color,\n            visible: a.visible\n          }, J(k) ? H.navigator.series : k);\n          q && !1 === c.navigatorOptions.adaptToUpdatedData || (l.name = \"Navigator \" + d.length, e = a.options || {}, h = e.navigatorOptions || {}, p.dataLabels = z(p.dataLabels), g = E(e, l, p, h), g.pointRange = K(p.pointRange, h.pointRange, H.plotOptions[g.type || \"line\"].pointRange), p = h.data || p.data, c.hasNavigatorData = c.hasNavigatorData || !!p, g.data = p || e.data && e.data.slice(0), q && q.options ? q.update(g, b) : (a.navigatorSeries = f.initSeries(g), a.navigatorSeries.baseSeries = a, n.push(a.navigatorSeries)));\n        });\n        if (k.data && (!d || !d.length) || J(k)) c.hasNavigatorData = !1, k = z(k), k.forEach(function (a, b) {\n          l.name = \"Navigator \" + (n.length + 1);\n          g = E(H.navigator.series, {\n            color: f.series[b] && !f.series[b].options.isInternal && f.series[b].color || f.options.colors[b] || f.options.colors[0]\n          }, l, a);\n          g.data = a.data;\n          g.data && (c.hasNavigatorData = !0, n.push(f.initSeries(g)));\n        });\n        a && this.addBaseSeriesEvents();\n      };\n\n      d.prototype.addBaseSeriesEvents = function () {\n        var a = this,\n            b = a.baseSeries || [];\n        b[0] && b[0].xAxis && b[0].eventsToUnbind.push(e(b[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        b.forEach(function (b) {\n          b.eventsToUnbind.push(e(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          }));\n          b.eventsToUnbind.push(e(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          }));\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(e(b, \"updatedData\", this.updatedDataHandler));\n          b.eventsToUnbind.push(e(b, \"remove\", function () {\n            this.navigatorSeries && (G(a.series, this.navigatorSeries), r(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        }, this);\n      };\n\n      d.prototype.getBaseSeriesMin = function (a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData ? b.xData[0] : a);\n        }, a);\n      };\n\n      d.prototype.modifyNavigatorAxisExtremes = function () {\n        var a = this.xAxis,\n            b;\n        \"undefined\" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));\n      };\n\n      d.prototype.modifyBaseAxisExtremes = function () {\n        var a = this.chart.navigator,\n            b = this.getExtremes(),\n            c = b.dataMin,\n            d = b.dataMax;\n        b = b.max - b.min;\n        var e = a.stickToMin,\n            g = a.stickToMax,\n            h = K(this.options.overscroll, 0),\n            l = a.series && a.series[0],\n            m = !!this.setExtremes;\n\n        if (!this.eventArgs || \"rangeSelectorButton\" !== this.eventArgs.trigger) {\n          if (e) {\n            var n = c;\n            var q = n + b;\n          }\n\n          g && (q = d + h, e || (n = Math.max(c, q - b, a.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE))));\n          m && (e || g) && M(n) && (this.min = this.userMin = n, this.max = this.userMax = q);\n        }\n\n        a.stickToMin = a.stickToMax = null;\n      };\n\n      d.prototype.updatedDataHandler = function () {\n        var a = this.chart.navigator,\n            b = this.navigatorSeries;\n        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);\n        a.stickToMin = a.shouldStickToMin(this, a);\n        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));\n      };\n\n      d.prototype.shouldStickToMin = function (a, b) {\n        b = b.getBaseSeriesMin(a.xData[0]);\n        var c = a.xAxis;\n        a = c.max;\n        var d = c.min;\n        c = c.options.range;\n        return M(a) && M(d) ? c && 0 < a - b ? a - b < c : d <= b : !1;\n      };\n\n      d.prototype.addChartEvents = function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(e(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          b && a.render(b.min, b.max);\n        }), e(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              b = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (b = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      };\n\n      d.prototype.destroy = function () {\n        this.removeEvents();\n        this.xAxis && (G(this.chart.xAxis, this.xAxis), G(this.chart.axes, this.xAxis));\n        this.yAxis && (G(this.chart.yAxis, this.yAxis), G(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          F(a);\n        }, this);\n      };\n\n      return d;\n    }();\n\n    u.Navigator || (u.Navigator = y, B.compose(b), e(t, \"beforeShowResetZoom\", function () {\n      var a = this.options,\n          b = a.navigator,\n          c = a.rangeSelector;\n      if ((b && b.enabled || c && c.enabled) && (!D && \"x\" === a.chart.zoomType || D && \"x\" === a.chart.pinchType)) return !1;\n    }), e(t, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new y(this);\n    }), e(t, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          b = this.navigator;\n\n      if (b) {\n        var c = a && a.options;\n        var d = b.xAxis;\n        var e = b.yAxis;\n        var g = b.scrollbarHeight;\n        this.inverted ? (b.left = b.opposite ? this.chartWidth - g - b.height : this.spacing[3] + g, b.top = this.plotTop + g) : (b.left = K(d.left, this.plotLeft + g), b.top = b.navigatorOptions.top || this.chartHeight - b.height - g - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && \"bottom\" === c.verticalAlign && \"proximate\" !== c.layout && c.enabled && !c.floating ? a.legendHeight + K(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        d && e && (this.inverted ? d.options.left = e.options.left = b.left : d.options.top = e.options.top = b.top, d.setAxisSize(), e.setAxisSize());\n      }\n    }), e(t, \"update\", function (a) {\n      var b = a.options.navigator || {},\n          c = a.options.scrollbar || {};\n      this.navigator || this.scroller || !b.enabled && !c.enabled || (E(!0, this.options.navigator, b), E(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);\n    }), e(t, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new y(this), K(a.redraw, !0) && this.redraw(a.animation));\n    }), e(t, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), e(d, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), t.prototype.callbacks.push(function (a) {\n      var b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }));\n    u.Navigator = y;\n    return u.Navigator;\n  });\n  J(b, \"masters/modules/gantt.src.js\", [b[\"Core/Globals.js\"], b[\"Core/Chart/GanttChart.js\"], b[\"Core/Scrollbar.js\"]], function (b, t, v) {\n    b.Scrollbar = v;\n    b.GanttChart = t;\n    b.ganttChart = t.ganttChart;\n    v.compose(b.Axis);\n  });\n});","map":null,"metadata":{},"sourceType":"script"}