{"ast":null,"code":"/*\n Highcharts JS v9.3.1 (2021-11-05)\n\n (c) 2016-2021 Highsoft AS\n Authors: Jon Arild Nygard\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (a) {\n  \"object\" === typeof module && module.exports ? (a[\"default\"] = a, module.exports = a) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/sunburst\", [\"highcharts\"], function (u) {\n    a(u);\n    a.Highcharts = u;\n    return a;\n  }) : a(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (a) {\n  function u(a, h, g, r) {\n    a.hasOwnProperty(h) || (a[h] = r.apply(null, g));\n  }\n\n  a = a ? a._modules : {};\n  u(a, \"Series/ColorMapComposition.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var h = a.defined,\n        g = a.wrap,\n        r = {\n      pointArrayMap: [\"value\"],\n      axisTypes: [\"xAxis\", \"yAxis\", \"colorAxis\"],\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      parallelArrays: [\"x\", \"y\", \"value\"],\n      colorKey: \"value\"\n    },\n        q;\n\n    (function (a) {\n      function k() {\n        return null !== this.value && Infinity !== this.value && -Infinity !== this.value;\n      }\n\n      function n(b) {\n        var d = {};\n        !h(b.color) || b.state && \"normal\" !== b.state || (d[this.colorProp || \"fill\"] = b.color);\n        return d;\n      }\n\n      function p(b, t, a) {\n        b = b.call(this, t, a);\n        t.moveToTopOnHover && (b.zIndex = \"hover\" === a ? 1 : 0);\n        return b;\n      }\n\n      a.colorMapSeriesMixin = r;\n      var b = [];\n\n      a.compose = function (d, t) {\n        t && -1 === b.indexOf(t) && (b.push(t), t = t.prototype, t.dataLabelOnNull = !0, t.moveToTopOnHover = !0, t.isValid = k);\n        -1 === b.indexOf(d) && (b.push(d), t = d.prototype, t.colorAttribs = n, g(t, \"pointAttribs\", p));\n        return d;\n      };\n\n      a.seriesColorAttribs = n;\n    })(q || (q = {}));\n\n    return q;\n  });\n  u(a, \"Series/Treemap/TreemapAlgorithmGroup.js\", [], function () {\n    return function () {\n      function a(a, g, r, q) {\n        this.height = a;\n        this.width = g;\n        this.plot = q;\n        this.startDirection = this.direction = r;\n        this.lH = this.nH = this.lW = this.nW = this.total = 0;\n        this.elArr = [];\n        this.lP = {\n          total: 0,\n          lH: 0,\n          nH: 0,\n          lW: 0,\n          nW: 0,\n          nR: 0,\n          lR: 0,\n          aspectRatio: function aspectRatio(a, c) {\n            return Math.max(a / c, c / a);\n          }\n        };\n      }\n\n      a.prototype.addElement = function (a) {\n        this.lP.total = this.elArr[this.elArr.length - 1];\n        this.total += a;\n        0 === this.direction ? (this.lW = this.nW, this.lP.lH = this.lP.total / this.lW, this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH), this.nW = this.total / this.height, this.lP.nH = this.lP.total / this.nW, this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH)) : (this.lH = this.nH, this.lP.lW = this.lP.total / this.lH, this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH), this.nH = this.total / this.width, this.lP.nW = this.lP.total / this.nH, this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH));\n        this.elArr.push(a);\n      };\n\n      a.prototype.reset = function () {\n        this.lW = this.nW = 0;\n        this.elArr = [];\n        this.total = 0;\n      };\n\n      return a;\n    }();\n  });\n  u(a, \"Series/DrawPointComposition.js\", [], function () {\n    var a;\n\n    (function (a) {\n      function g(a) {\n        var c = this,\n            n = a.animatableAttribs,\n            p = a.onComplete,\n            b = a.css,\n            d = a.renderer,\n            t = this.series && this.series.chart.hasRendered ? void 0 : this.series && this.series.options.animation,\n            x = this.graphic;\n        a.attribs = a.attribs || {};\n        a.attribs[\"class\"] = this.getClassName();\n        if (this.shouldDraw()) x || (this.graphic = x = d[a.shapeType](a.shapeArgs).add(a.group)), x.css(b).attr(a.attribs).animate(n, a.isNew ? !1 : t, p);else if (x) {\n          var B = function B() {\n            c.graphic = x = x && x.destroy();\n            \"function\" === typeof p && p();\n          };\n\n          Object.keys(n).length ? x.animate(n, void 0, function () {\n            B();\n          }) : B();\n        }\n      }\n\n      function h() {\n        return !this.isNull;\n      }\n\n      var q = [];\n\n      a.compose = function (a) {\n        if (-1 === q.indexOf(a)) {\n          q.push(a);\n          var c = a.prototype;\n          c.draw = g;\n          c.shouldDraw || (c.shouldDraw = h);\n        }\n\n        return a;\n      };\n    })(a || (a = {}));\n\n    return a;\n  });\n  u(a, \"Series/Treemap/TreemapPoint.js\", [a[\"Series/DrawPointComposition.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, h, g) {\n    var r = this && this.__extends || function () {\n      var _b = function b(a, t) {\n        _b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var d in a) {\n            a.hasOwnProperty(d) && (b[d] = a[d]);\n          }\n        };\n\n        return _b(a, t);\n      };\n\n      return function (a, t) {\n        function d() {\n          this.constructor = a;\n        }\n\n        _b(a, t);\n\n        a.prototype = null === t ? Object.create(t) : (d.prototype = t.prototype, new d());\n      };\n    }(),\n        q = h.series.prototype.pointClass,\n        k = h.seriesTypes;\n\n    h = k.pie.prototype.pointClass;\n    var c = g.extend,\n        n = g.isNumber,\n        p = g.pick;\n\n    g = function (b) {\n      function a() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.name = void 0;\n        a.node = void 0;\n        a.options = void 0;\n        a.series = void 0;\n        a.value = void 0;\n        return a;\n      }\n\n      r(a, b);\n\n      a.prototype.getClassName = function () {\n        var a = q.prototype.getClassName.call(this),\n            b = this.series,\n            d = b.options;\n        this.node.level <= b.nodeMap[b.rootNode].level ? a += \" highcharts-above-level\" : this.node.isLeaf || p(d.interactByLeaf, !d.allowTraversingTree) ? this.node.isLeaf || (a += \" highcharts-internal-node\") : a += \" highcharts-internal-node-interactive\";\n        return a;\n      };\n\n      a.prototype.isValid = function () {\n        return !(!this.id && !n(this.value));\n      };\n\n      a.prototype.setState = function (a) {\n        q.prototype.setState.call(this, a);\n        this.graphic && this.graphic.attr({\n          zIndex: \"hover\" === a ? 1 : 0\n        });\n      };\n\n      a.prototype.shouldDraw = function () {\n        return n(this.plotY) && null !== this.y;\n      };\n\n      return a;\n    }(k.scatter.prototype.pointClass);\n\n    c(g.prototype, {\n      setVisible: h.prototype.setVisible\n    });\n    a.compose(g);\n    return g;\n  });\n  u(a, \"Series/Treemap/TreemapUtilities.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var h = a.objectEach,\n        g;\n\n    (function (a) {\n      function g(a, c, n) {\n        void 0 === n && (n = this);\n        a = c.call(n, a);\n        !1 !== a && g(a, c, n);\n      }\n\n      a.AXIS_MAX = 100;\n\n      a.isBoolean = function (a) {\n        return \"boolean\" === typeof a;\n      };\n\n      a.eachObject = function (a, c, n) {\n        n = n || this;\n        h(a, function (p, b) {\n          c.call(n, p, b, a);\n        });\n      };\n\n      a.recursive = g;\n    })(g || (g = {}));\n\n    return g;\n  });\n  u(a, \"Series/TreeUtilities.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Utilities.js\"]], function (a, h) {\n    function g(a, d) {\n      var b = d.before,\n          n = d.idRoot,\n          c = d.mapIdToNode[n],\n          h = d.points[a.i],\n          q = h && h.options || {},\n          k = [],\n          w = 0;\n      a.levelDynamic = a.level - (!1 !== d.levelIsConstant ? 0 : c.level);\n      a.name = p(h && h.name, \"\");\n      a.visible = n === a.id || !0 === d.visible;\n      \"function\" === typeof b && (a = b(a, d));\n      a.children.forEach(function (b, n) {\n        var c = r({}, d);\n        r(c, {\n          index: n,\n          siblings: a.children.length,\n          visible: a.visible\n        });\n        b = g(b, c);\n        k.push(b);\n        b.visible && (w += b.val);\n      });\n      b = p(q.value, w);\n      a.visible = 0 <= b && (0 < w || a.visible);\n      a.children = k;\n      a.childrenTotal = w;\n      a.isLeaf = a.visible && !w;\n      a.val = b;\n      return a;\n    }\n\n    var r = h.extend,\n        q = h.isArray,\n        k = h.isNumber,\n        c = h.isObject,\n        n = h.merge,\n        p = h.pick;\n    return {\n      getColor: function getColor(b, d) {\n        var n = d.index,\n            c = d.mapOptionsToLevel,\n            h = d.parentColor,\n            g = d.parentColorIndex,\n            q = d.series,\n            k = d.colors,\n            w = d.siblings,\n            r = q.points,\n            u = q.chart.options.chart,\n            z;\n\n        if (b) {\n          r = r[b.i];\n          b = c[b.level] || {};\n\n          if (c = r && b.colorByPoint) {\n            var D = r.index % (k ? k.length : u.colorCount);\n            var F = k && k[D];\n          }\n\n          if (!q.chart.styledMode) {\n            k = r && r.options.color;\n            u = b && b.color;\n            if (z = h) z = (z = b && b.colorVariation) && \"brightness\" === z.key && n && w ? a.parse(h).brighten(n / w * z.to).get() : h;\n            z = p(k, u, F, z, q.color);\n          }\n\n          var G = p(r && r.options.colorIndex, b && b.colorIndex, D, g, d.colorIndex);\n        }\n\n        return {\n          color: z,\n          colorIndex: G\n        };\n      },\n      getLevelOptions: function getLevelOptions(a) {\n        var b = null;\n\n        if (c(a)) {\n          b = {};\n          var h = k(a.from) ? a.from : 1;\n          var g = a.levels;\n          var r = {};\n          var z = c(a.defaults) ? a.defaults : {};\n          q(g) && (r = g.reduce(function (a, b) {\n            if (c(b) && k(b.level)) {\n              var d = n({}, b);\n              var g = p(d.levelIsConstant, z.levelIsConstant);\n              delete d.levelIsConstant;\n              delete d.level;\n              b = b.level + (g ? 0 : h - 1);\n              c(a[b]) ? n(!0, a[b], d) : a[b] = d;\n            }\n\n            return a;\n          }, {}));\n          g = k(a.to) ? a.to : 1;\n\n          for (a = 0; a <= g; a++) {\n            b[a] = n({}, z, c(r[a]) ? r[a] : {});\n          }\n        }\n\n        return b;\n      },\n      setTreeValues: g,\n      updateRootId: function updateRootId(a) {\n        if (c(a)) {\n          var b = c(a.options) ? a.options : {};\n          b = p(a.rootNode, b.rootId, \"\");\n          c(a.userOptions) && (a.userOptions.rootId = b);\n          a.rootNode = b;\n        }\n\n        return b;\n      }\n    };\n  });\n  u(a, \"Series/Treemap/TreemapComposition.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Treemap/TreemapUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, h, g) {\n    var r = g.addEvent,\n        q = g.extend,\n        k = !1;\n    r(a.series, \"afterBindAxes\", function () {\n      var a = this.xAxis,\n          n = this.yAxis;\n      if (a && n) if (this.is(\"treemap\")) {\n        var g = {\n          endOnTick: !1,\n          gridLineWidth: 0,\n          lineWidth: 0,\n          min: 0,\n          minPadding: 0,\n          max: h.AXIS_MAX,\n          maxPadding: 0,\n          startOnTick: !1,\n          title: void 0,\n          tickPositions: []\n        };\n        q(n.options, g);\n        q(a.options, g);\n        k = !0;\n      } else k && (n.setOptions(n.userOptions), a.setOptions(a.userOptions), k = !1);\n    });\n  });\n  u(a, \"Series/Treemap/TreemapSeries.js\", [a[\"Core/Color/Color.js\"], a[\"Series/ColorMapComposition.js\"], a[\"Core/Globals.js\"], a[\"Core/Legend/LegendSymbol.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Treemap/TreemapAlgorithmGroup.js\"], a[\"Series/Treemap/TreemapPoint.js\"], a[\"Series/Treemap/TreemapUtilities.js\"], a[\"Series/TreeUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, h, g, r, q, k, c, n, p, b) {\n    var d = this && this.__extends || function () {\n      var _a = function a(b, e) {\n        _a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (e, a) {\n          e.__proto__ = a;\n        } || function (e, a) {\n          for (var m in a) {\n            a.hasOwnProperty(m) && (e[m] = a[m]);\n          }\n        };\n\n        return _a(b, e);\n      };\n\n      return function (b, e) {\n        function m() {\n          this.constructor = b;\n        }\n\n        _a(b, e);\n\n        b.prototype = null === e ? Object.create(e) : (m.prototype = e.prototype, new m());\n      };\n    }(),\n        t = a.parse,\n        x = h.colorMapSeriesMixin;\n\n    a = g.noop;\n    var B = q.series;\n    g = q.seriesTypes;\n    var z = g.column,\n        u = g.heatmap,\n        L = g.scatter,\n        w = p.getColor,\n        N = p.getLevelOptions,\n        K = p.updateRootId,\n        I = b.addEvent,\n        D = b.correctFloat,\n        F = b.defined,\n        G = b.error,\n        J = b.extend,\n        O = b.fireEvent,\n        P = b.isArray,\n        T = b.isObject,\n        f = b.isString,\n        C = b.merge,\n        v = b.pick,\n        U = b.stableSort;\n\n    p = function (a) {\n      function b() {\n        var e = null !== a && a.apply(this, arguments) || this;\n        e.axisRatio = void 0;\n        e.data = void 0;\n        e.mapOptionsToLevel = void 0;\n        e.nodeMap = void 0;\n        e.options = void 0;\n        e.points = void 0;\n        e.rootNode = void 0;\n        e.tree = void 0;\n        return e;\n      }\n\n      d(b, a);\n\n      b.prototype.algorithmCalcPoints = function (a, b, l, f) {\n        var e,\n            m,\n            A,\n            d,\n            n = l.lW,\n            g = l.lH,\n            c = l.plot,\n            h = 0,\n            t = l.elArr.length - 1;\n        if (b) n = l.nW, g = l.nH;else var H = l.elArr[l.elArr.length - 1];\n        l.elArr.forEach(function (a) {\n          if (b || h < t) 0 === l.direction ? (e = c.x, m = c.y, A = n, d = a / A) : (e = c.x, m = c.y, d = g, A = a / d), f.push({\n            x: e,\n            y: m,\n            width: A,\n            height: D(d)\n          }), 0 === l.direction ? c.y += d : c.x += A;\n          h += 1;\n        });\n        l.reset();\n        0 === l.direction ? l.width -= n : l.height -= g;\n        c.y = c.parent.y + (c.parent.height - l.height);\n        c.x = c.parent.x + (c.parent.width - l.width);\n        a && (l.direction = 1 - l.direction);\n        b || l.addElement(H);\n      };\n\n      b.prototype.algorithmFill = function (a, b, l) {\n        var e = [],\n            m,\n            f = b.direction,\n            d = b.x,\n            c = b.y,\n            n = b.width,\n            g = b.height,\n            h,\n            t,\n            p,\n            H;\n        l.forEach(function (l) {\n          m = l.val / b.val * b.height * b.width;\n          h = d;\n          t = c;\n          0 === f ? (H = g, p = m / H, n -= p, d += p) : (p = n, H = m / p, g -= H, c += H);\n          e.push({\n            x: h,\n            y: t,\n            width: p,\n            height: H\n          });\n          a && (f = 1 - f);\n        });\n        return e;\n      };\n\n      b.prototype.algorithmLowAspectRatio = function (a, b, l) {\n        var e = [],\n            m = this,\n            f,\n            d = {\n          x: b.x,\n          y: b.y,\n          parent: b\n        },\n            c = 0,\n            n = l.length - 1,\n            g = new k(b.height, b.width, b.direction, d);\n        l.forEach(function (l) {\n          f = l.val / b.val * b.height * b.width;\n          g.addElement(f);\n          g.lP.nR > g.lP.lR && m.algorithmCalcPoints(a, !1, g, e, d);\n          c === n && m.algorithmCalcPoints(a, !0, g, e, d);\n          c += 1;\n        });\n        return e;\n      };\n\n      b.prototype.alignDataLabel = function (a, b, l) {\n        var e = l.style;\n        e && !F(e.textOverflow) && b.text && b.getBBox().width > b.text.textWidth && b.css({\n          textOverflow: \"ellipsis\",\n          width: e.width += \"px\"\n        });\n        z.prototype.alignDataLabel.apply(this, arguments);\n        a.dataLabel && a.dataLabel.attr({\n          zIndex: (a.node.zIndex || 0) + 1\n        });\n      };\n\n      b.prototype.buildNode = function (a, b, l, f, d) {\n        var e = this,\n            m = [],\n            E = e.points[b],\n            c = 0,\n            A;\n        (f[a] || []).forEach(function (b) {\n          A = e.buildNode(e.points[b].id, b, l + 1, f, a);\n          c = Math.max(A.height + 1, c);\n          m.push(A);\n        });\n        b = {\n          id: a,\n          i: b,\n          children: m,\n          height: c,\n          level: l,\n          parent: d,\n          visible: !1\n        };\n        e.nodeMap[b.id] = b;\n        E && (E.node = b);\n        return b;\n      };\n\n      b.prototype.calculateChildrenAreas = function (a, b) {\n        var e = this,\n            m = e.options,\n            f = e.mapOptionsToLevel[a.level + 1],\n            d = v(e[f && f.layoutAlgorithm] && f.layoutAlgorithm, m.layoutAlgorithm),\n            c = m.alternateStartingDirection,\n            g = [];\n        a = a.children.filter(function (a) {\n          return !a.ignore;\n        });\n        f && f.layoutStartingDirection && (b.direction = \"vertical\" === f.layoutStartingDirection ? 0 : 1);\n        g = e[d](b, a);\n        a.forEach(function (a, m) {\n          m = g[m];\n          a.values = C(m, {\n            val: a.childrenTotal,\n            direction: c ? 1 - b.direction : b.direction\n          });\n          a.pointValues = C(m, {\n            x: m.x / e.axisRatio,\n            y: n.AXIS_MAX - m.y - m.height,\n            width: m.width / e.axisRatio\n          });\n          a.children.length && e.calculateChildrenAreas(a, a.values);\n        });\n      };\n\n      b.prototype.drawDataLabels = function () {\n        var a = this,\n            b = a.mapOptionsToLevel,\n            f,\n            d;\n        a.points.filter(function (a) {\n          return a.node.visible;\n        }).forEach(function (e) {\n          d = b[e.node.level];\n          f = {\n            style: {}\n          };\n          e.node.isLeaf || (f.enabled = !1);\n          d && d.dataLabels && (f = C(f, d.dataLabels), a._hasPointLabels = !0);\n          e.shapeArgs && (f.style.width = e.shapeArgs.width, e.dataLabel && e.dataLabel.css({\n            width: e.shapeArgs.width + \"px\"\n          }));\n          e.dlOptions = C(f, e.options.dataLabels);\n        });\n        B.prototype.drawDataLabels.call(this);\n      };\n\n      b.prototype.drawPoints = function () {\n        var a = this,\n            b = a.chart,\n            f = b.renderer,\n            d = b.styledMode,\n            c = a.options,\n            g = d ? {} : c.shadow,\n            n = c.borderRadius,\n            h = b.pointCount < c.animationLimit,\n            t = c.allowTraversingTree;\n        a.points.forEach(function (e) {\n          var b = e.node.levelDynamic,\n              m = {},\n              l = {},\n              A = {},\n              E = \"level-group-\" + e.node.level,\n              p = !!e.graphic,\n              V = h && p,\n              Q = e.shapeArgs;\n          e.shouldDraw() && (e.isInside = !0, n && (l.r = n), C(!0, V ? m : l, p ? Q : {}, d ? {} : a.pointAttribs(e, e.selected ? \"select\" : void 0)), a.colorAttribs && d && J(A, a.colorAttribs(e)), a[E] || (a[E] = f.g(E).attr({\n            zIndex: 1E3 - (b || 0)\n          }).add(a.group), a[E].survive = !0));\n          e.draw({\n            animatableAttribs: m,\n            attribs: l,\n            css: A,\n            group: a[E],\n            renderer: f,\n            shadow: g,\n            shapeArgs: Q,\n            shapeType: \"rect\"\n          });\n          t && e.graphic && (e.drillId = c.interactByLeaf ? a.drillToByLeaf(e) : a.drillToByGroup(e));\n        });\n      };\n\n      b.prototype.drillToByGroup = function (a) {\n        var e = !1;\n        1 !== a.node.level - this.nodeMap[this.rootNode].level || a.node.isLeaf || (e = a.id);\n        return e;\n      };\n\n      b.prototype.drillToByLeaf = function (a) {\n        var e = !1;\n        if (a.node.parent !== this.rootNode && a.node.isLeaf) for (a = a.node; !e;) {\n          a = this.nodeMap[a.parent], a.parent === this.rootNode && (e = a.id);\n        }\n        return e;\n      };\n\n      b.prototype.drillToNode = function (a, b) {\n        G(32, !1, void 0, {\n          \"treemap.drillToNode\": \"use treemap.setRootNode\"\n        });\n        this.setRootNode(a, b);\n      };\n\n      b.prototype.drillUp = function () {\n        var a = this.nodeMap[this.rootNode];\n        a && f(a.parent) && this.setRootNode(a.parent, !0, {\n          trigger: \"traverseUpButton\"\n        });\n      };\n\n      b.prototype.getExtremes = function () {\n        var a = B.prototype.getExtremes.call(this, this.colorValueData),\n            b = a.dataMax;\n        this.valueMin = a.dataMin;\n        this.valueMax = b;\n        return B.prototype.getExtremes.call(this);\n      };\n\n      b.prototype.getListOfParents = function (a, b) {\n        a = P(a) ? a : [];\n        var e = P(b) ? b : [];\n        b = a.reduce(function (a, e, b) {\n          e = v(e.parent, \"\");\n          \"undefined\" === typeof a[e] && (a[e] = []);\n          a[e].push(b);\n          return a;\n        }, {\n          \"\": []\n        });\n        n.eachObject(b, function (a, b, f) {\n          \"\" !== b && -1 === e.indexOf(b) && (a.forEach(function (a) {\n            f[\"\"].push(a);\n          }), delete f[b]);\n        });\n        return b;\n      };\n\n      b.prototype.getTree = function () {\n        var a = this.data.map(function (a) {\n          return a.id;\n        });\n        a = this.getListOfParents(this.data, a);\n        this.nodeMap = {};\n        return this.buildNode(\"\", -1, 0, a);\n      };\n\n      b.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      b.prototype.init = function (a, b) {\n        x && (this.colorAttribs = h.seriesColorAttribs);\n        var e = I(this, \"setOptions\", function (a) {\n          a = a.userOptions;\n          F(a.allowDrillToNode) && !F(a.allowTraversingTree) && (a.allowTraversingTree = a.allowDrillToNode, delete a.allowDrillToNode);\n          F(a.drillUpButton) && !F(a.traverseUpButton) && (a.traverseUpButton = a.drillUpButton, delete a.drillUpButton);\n        });\n        B.prototype.init.call(this, a, b);\n        delete this.opacity;\n        this.eventsToUnbind.push(e);\n        this.options.allowTraversingTree && this.eventsToUnbind.push(I(this, \"click\", this.onClickDrillToNode));\n      };\n\n      b.prototype.onClickDrillToNode = function (a) {\n        var b = (a = a.point) && a.drillId;\n        f(b) && (a.setState(\"\"), this.setRootNode(b, !0, {\n          trigger: \"click\"\n        }));\n      };\n\n      b.prototype.pointAttribs = function (a, b) {\n        var e = T(this.mapOptionsToLevel) ? this.mapOptionsToLevel : {},\n            f = a && e[a.node.level] || {};\n        e = this.options;\n        var d = b && e.states[b] || {},\n            m = a && a.getClassName() || \"\";\n        a = {\n          stroke: a && a.borderColor || f.borderColor || d.borderColor || e.borderColor,\n          \"stroke-width\": v(a && a.borderWidth, f.borderWidth, d.borderWidth, e.borderWidth),\n          dashstyle: a && a.borderDashStyle || f.borderDashStyle || d.borderDashStyle || e.borderDashStyle,\n          fill: a && a.color || this.color\n        };\n        -1 !== m.indexOf(\"highcharts-above-level\") ? (a.fill = \"none\", a[\"stroke-width\"] = 0) : -1 !== m.indexOf(\"highcharts-internal-node-interactive\") ? (b = v(d.opacity, e.opacity), a.fill = t(a.fill).setOpacity(b).get(), a.cursor = \"pointer\") : -1 !== m.indexOf(\"highcharts-internal-node\") ? a.fill = \"none\" : b && (a.fill = t(a.fill).brighten(d.brightness).get());\n        return a;\n      };\n\n      b.prototype.renderTraverseUpButton = function (a) {\n        var b = this,\n            e = b.options.traverseUpButton,\n            f = v(e.text, b.nodeMap[a].name, \"\\u25C1 Back\");\n        if (\"\" === a || b.is(\"sunburst\") && 1 === b.tree.children.length && a === b.tree.children[0].id) b.drillUpButton && (b.drillUpButton = b.drillUpButton.destroy());else if (this.drillUpButton) this.drillUpButton.placed = !1, this.drillUpButton.attr({\n          text: f\n        }).align();else {\n          var d = (a = e.theme) && a.states;\n          this.drillUpButton = this.chart.renderer.button(f, 0, 0, function () {\n            b.drillUp();\n          }, a, d && d.hover, d && d.select).addClass(\"highcharts-drillup-button\").attr({\n            align: e.position.align,\n            zIndex: 7\n          }).add().align(e.position, !1, e.relativeTo || \"plotBox\");\n        }\n      };\n\n      b.prototype.setColorRecursive = function (a, b, f, d, c) {\n        var e = this,\n            m = e && e.chart;\n        m = m && m.options && m.options.colors;\n\n        if (a) {\n          var l = w(a, {\n            colors: m,\n            index: d,\n            mapOptionsToLevel: e.mapOptionsToLevel,\n            parentColor: b,\n            parentColorIndex: f,\n            series: e,\n            siblings: c\n          });\n          if (b = e.points[a.i]) b.color = l.color, b.colorIndex = l.colorIndex;\n          (a.children || []).forEach(function (b, f) {\n            e.setColorRecursive(b, l.color, l.colorIndex, f, a.children.length);\n          });\n        }\n      };\n\n      b.prototype.setPointValues = function () {\n        var a = this,\n            b = a.xAxis,\n            f = a.yAxis,\n            d = a.chart.styledMode;\n        a.points.forEach(function (e) {\n          var m = e.node,\n              c = m.pointValues;\n          m = m.visible;\n\n          if (c && m) {\n            m = c.height;\n            var l = c.width,\n                g = c.x,\n                n = c.y,\n                h = d ? 0 : (a.pointAttribs(e)[\"stroke-width\"] || 0) % 2 / 2;\n            c = Math.round(b.toPixels(g, !0)) - h;\n            l = Math.round(b.toPixels(g + l, !0)) - h;\n            g = Math.round(f.toPixels(n, !0)) - h;\n            m = Math.round(f.toPixels(n + m, !0)) - h;\n            m = {\n              x: Math.min(c, l),\n              y: Math.min(g, m),\n              width: Math.abs(l - c),\n              height: Math.abs(m - g)\n            };\n            e.plotX = m.x + m.width / 2;\n            e.plotY = m.y + m.height / 2;\n            e.shapeArgs = m;\n          } else delete e.plotX, delete e.plotY;\n        });\n      };\n\n      b.prototype.setRootNode = function (a, b, f) {\n        a = J({\n          newRootId: a,\n          previousRootId: this.rootNode,\n          redraw: v(b, !0),\n          series: this\n        }, f);\n        O(this, \"setRootNode\", a, function (a) {\n          var b = a.series;\n          b.idPreviousRoot = a.previousRootId;\n          b.rootNode = a.newRootId;\n          b.isDirty = !0;\n          a.redraw && b.chart.redraw();\n        });\n      };\n\n      b.prototype.setState = function (a) {\n        this.options.inactiveOtherPoints = !0;\n        B.prototype.setState.call(this, a, !1);\n        this.options.inactiveOtherPoints = !1;\n      };\n\n      b.prototype.setTreeValues = function (a) {\n        var b = this,\n            e = b.options,\n            f = b.nodeMap[b.rootNode];\n        e = n.isBoolean(e.levelIsConstant) ? e.levelIsConstant : !0;\n        var d = 0,\n            c = [],\n            g = b.points[a.i];\n        a.children.forEach(function (a) {\n          a = b.setTreeValues(a);\n          c.push(a);\n          a.ignore || (d += a.val);\n        });\n        U(c, function (a, b) {\n          return (a.sortIndex || 0) - (b.sortIndex || 0);\n        });\n        var h = v(g && g.options.value, d);\n        g && (g.value = h);\n        J(a, {\n          children: c,\n          childrenTotal: d,\n          ignore: !(v(g && g.visible, !0) && 0 < h),\n          isLeaf: a.visible && !d,\n          levelDynamic: a.level - (e ? 0 : f.level),\n          name: v(g && g.name, \"\"),\n          sortIndex: v(g && g.sortIndex, -h),\n          val: h\n        });\n        return a;\n      };\n\n      b.prototype.sliceAndDice = function (a, b) {\n        return this.algorithmFill(!0, a, b);\n      };\n\n      b.prototype.squarified = function (a, b) {\n        return this.algorithmLowAspectRatio(!0, a, b);\n      };\n\n      b.prototype.strip = function (a, b) {\n        return this.algorithmLowAspectRatio(!1, a, b);\n      };\n\n      b.prototype.stripes = function (a, b) {\n        return this.algorithmFill(!1, a, b);\n      };\n\n      b.prototype.translate = function () {\n        var a = this,\n            b = a.options,\n            f = K(a);\n        B.prototype.translate.call(a);\n        var d = a.tree = a.getTree();\n        var c = a.nodeMap[f];\n        \"\" === f || c && c.children.length || (a.setRootNode(\"\", !1), f = a.rootNode, c = a.nodeMap[f]);\n        a.renderTraverseUpButton(f);\n        a.mapOptionsToLevel = N({\n          from: c.level + 1,\n          levels: b.levels,\n          to: d.height,\n          defaults: {\n            levelIsConstant: a.options.levelIsConstant,\n            colorByPoint: b.colorByPoint\n          }\n        });\n        n.recursive(a.nodeMap[a.rootNode], function (b) {\n          var e = !1,\n              f = b.parent;\n          b.visible = !0;\n          if (f || \"\" === f) e = a.nodeMap[f];\n          return e;\n        });\n        n.recursive(a.nodeMap[a.rootNode].children, function (a) {\n          var b = !1;\n          a.forEach(function (a) {\n            a.visible = !0;\n            a.children.length && (b = (b || []).concat(a.children));\n          });\n          return b;\n        });\n        a.setTreeValues(d);\n        a.axisRatio = a.xAxis.len / a.yAxis.len;\n        a.nodeMap[\"\"].pointValues = f = {\n          x: 0,\n          y: 0,\n          width: n.AXIS_MAX,\n          height: n.AXIS_MAX\n        };\n        a.nodeMap[\"\"].values = f = C(f, {\n          width: f.width * a.axisRatio,\n          direction: \"vertical\" === b.layoutStartingDirection ? 0 : 1,\n          val: d.val\n        });\n        a.calculateChildrenAreas(d, f);\n        a.colorAxis || b.colorByPoint || a.setColorRecursive(a.tree);\n        b.allowTraversingTree && (b = c.pointValues, a.xAxis.setExtremes(b.x, b.x + b.width, !1), a.yAxis.setExtremes(b.y, b.y + b.height, !1), a.xAxis.setScale(), a.yAxis.setScale());\n        a.setPointValues();\n      };\n\n      b.defaultOptions = C(L.defaultOptions, {\n        allowTraversingTree: !1,\n        animationLimit: 250,\n        borderRadius: 0,\n        showInLegend: !1,\n        marker: void 0,\n        colorByPoint: !1,\n        dataLabels: {\n          defer: !1,\n          enabled: !0,\n          formatter: function formatter() {\n            var a = this && this.point ? this.point : {};\n            return f(a.name) ? a.name : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        tooltip: {\n          headerFormat: \"\",\n          pointFormat: \"<b>{point.name}</b>: {point.value}<br/>\"\n        },\n        ignoreHiddenPoint: !0,\n        layoutAlgorithm: \"sliceAndDice\",\n        layoutStartingDirection: \"vertical\",\n        alternateStartingDirection: !1,\n        levelIsConstant: !0,\n        drillUpButton: {\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        traverseUpButton: {\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        borderColor: \"#e6e6e6\",\n        borderWidth: 1,\n        colorKey: \"colorValue\",\n        opacity: .15,\n        states: {\n          hover: {\n            borderColor: \"#999999\",\n            brightness: u ? 0 : .1,\n            halo: !1,\n            opacity: .75,\n            shadow: !1\n          }\n        }\n      });\n      return b;\n    }(L);\n\n    J(p.prototype, {\n      buildKDTree: a,\n      colorKey: \"colorValue\",\n      directTouch: !0,\n      drawLegendSymbol: r.drawRectangle,\n      getExtremesFromAll: !0,\n      getSymbol: a,\n      optionalAxis: \"colorAxis\",\n      parallelArrays: [\"x\", \"y\", \"value\", \"colorValue\"],\n      pointArrayMap: [\"value\"],\n      pointClass: c,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      utils: {\n        recursive: n.recursive\n      }\n    });\n    h.compose(p);\n    q.registerSeriesType(\"treemap\", p);\n    \"\";\n    return p;\n  });\n  u(a, \"Series/Sunburst/SunburstPoint.js\", [a[\"Series/DrawPointComposition.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, h, g) {\n    var r = this && this.__extends || function () {\n      var _a2 = function a(c, g) {\n        _a2 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, d) {\n          a.__proto__ = d;\n        } || function (a, d) {\n          for (var b in d) {\n            d.hasOwnProperty(b) && (a[b] = d[b]);\n          }\n        };\n\n        return _a2(c, g);\n      };\n\n      return function (c, g) {\n        function b() {\n          this.constructor = c;\n        }\n\n        _a2(c, g);\n\n        c.prototype = null === g ? Object.create(g) : (b.prototype = g.prototype, new b());\n      };\n    }(),\n        q = h.series.prototype.pointClass,\n        k = g.correctFloat;\n\n    g = g.extend;\n\n    h = function (a) {\n      function c() {\n        var c = null !== a && a.apply(this, arguments) || this;\n        c.node = void 0;\n        c.options = void 0;\n        c.series = void 0;\n        c.shapeExisting = void 0;\n        return c;\n      }\n\n      r(c, a);\n\n      c.prototype.getDataLabelPath = function (a) {\n        var b = this.series.chart.renderer,\n            d = this.shapeExisting,\n            c = d.start,\n            g = d.end,\n            h = c + (g - c) / 2;\n        h = 0 > h && h > -Math.PI || h > Math.PI;\n        var n = d.r + (a.options.distance || 0);\n        c === -Math.PI / 2 && k(g) === k(1.5 * Math.PI) && (c = -Math.PI + Math.PI / 360, g = -Math.PI / 360, h = !0);\n\n        if (g - c > Math.PI) {\n          h = !1;\n          var p = !0;\n        }\n\n        this.dataLabelPath && (this.dataLabelPath = this.dataLabelPath.destroy());\n        this.dataLabelPath = b.arc({\n          open: !0,\n          longArc: p ? 1 : 0\n        }).add(a);\n        this.dataLabelPath.attr({\n          start: h ? c : g,\n          end: h ? g : c,\n          clockwise: +h,\n          x: d.x,\n          y: d.y,\n          r: (n + d.innerR) / 2\n        });\n        return this.dataLabelPath;\n      };\n\n      c.prototype.isValid = function () {\n        return !0;\n      };\n\n      return c;\n    }(h.seriesTypes.treemap.prototype.pointClass);\n\n    g(h.prototype, {\n      getClassName: q.prototype.getClassName,\n      haloPath: q.prototype.haloPath,\n      setState: q.prototype.setState\n    });\n    a.compose(h);\n    return h;\n  });\n  u(a, \"Series/Sunburst/SunburstUtilities.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, h) {\n    var g = a.seriesTypes.treemap,\n        r = h.isNumber,\n        q = h.isObject,\n        k = h.merge,\n        c;\n\n    (function (a) {\n      function c(a, d) {\n        var b = [];\n        if (r(a) && r(d) && a <= d) for (; a <= d; a++) {\n          b.push(a);\n        }\n        return b;\n      }\n\n      a.recursive = g.prototype.utils.recursive;\n\n      a.calculateLevelSizes = function (a, d) {\n        d = q(d) ? d : {};\n        var b = 0,\n            g;\n\n        if (q(a)) {\n          var h = k({}, a);\n          a = r(d.from) ? d.from : 0;\n          var n = r(d.to) ? d.to : 0;\n          var p = c(a, n);\n          a = Object.keys(h).filter(function (a) {\n            return -1 === p.indexOf(+a);\n          });\n          var u = g = r(d.diffRadius) ? d.diffRadius : 0;\n          p.forEach(function (a) {\n            a = h[a];\n            var d = a.levelSize.unit,\n                c = a.levelSize.value;\n            \"weight\" === d ? b += c : \"percentage\" === d ? (a.levelSize = {\n              unit: \"pixels\",\n              value: c / 100 * u\n            }, g -= a.levelSize.value) : \"pixels\" === d && (g -= c);\n          });\n          p.forEach(function (a) {\n            var d = h[a];\n            \"weight\" === d.levelSize.unit && (d = d.levelSize.value, h[a].levelSize = {\n              unit: \"pixels\",\n              value: d / b * g\n            });\n          });\n          a.forEach(function (a) {\n            h[a].levelSize = {\n              value: 0,\n              unit: \"pixels\"\n            };\n          });\n        }\n\n        return h;\n      };\n\n      a.getLevelFromAndTo = function (a) {\n        var b = a.level;\n        return {\n          from: 0 < b ? b : 1,\n          to: b + a.height\n        };\n      };\n\n      a.range = c;\n    })(c || (c = {}));\n\n    return c;\n  });\n  u(a, \"Series/Sunburst/SunburstSeries.js\", [a[\"Series/CenteredUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Sunburst/SunburstPoint.js\"], a[\"Series/Sunburst/SunburstUtilities.js\"], a[\"Series/TreeUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, h, g, r, q, k, c) {\n    function n(a, b) {\n      var f = b.mapIdToNode[a.parent],\n          d = b.series,\n          c = d.chart,\n          g = d.points[a.i];\n      f = R(a, {\n        colors: d.options.colors || c && c.options.colors,\n        colorIndex: d.colorIndex,\n        index: b.index,\n        mapOptionsToLevel: b.mapOptionsToLevel,\n        parentColor: f && f.color,\n        parentColorIndex: f && f.colorIndex,\n        series: b.series,\n        siblings: b.siblings\n      });\n      a.color = f.color;\n      a.colorIndex = f.colorIndex;\n      g && (g.color = a.color, g.colorIndex = a.colorIndex, a.sliced = a.id !== b.idRoot ? g.sliced : !1);\n      return a;\n    }\n\n    var p = this && this.__extends || function () {\n      var _a3 = function a(b, f) {\n        _a3 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var f in b) {\n            b.hasOwnProperty(f) && (a[f] = b[f]);\n          }\n        };\n\n        return _a3(b, f);\n      };\n\n      return function (b, f) {\n        function d() {\n          this.constructor = b;\n        }\n\n        _a3(b, f);\n\n        b.prototype = null === f ? Object.create(f) : (d.prototype = f.prototype, new d());\n      };\n    }(),\n        b = a.getCenter,\n        d = a.getStartAndEndRadians;\n\n    a = h.noop;\n    var t = g.series,\n        u = g.seriesTypes;\n    h = u.column;\n    var z = u.treemap,\n        R = k.getColor,\n        S = k.getLevelOptions,\n        L = k.setTreeValues,\n        w = k.updateRootId,\n        N = c.error,\n        K = c.extend,\n        I = c.isNumber,\n        D = c.isObject,\n        F = c.isString,\n        G = c.merge,\n        J = c.splat,\n        O = 180 / Math.PI;\n\n    k = function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.center = void 0;\n        b.data = void 0;\n        b.mapOptionsToLevel = void 0;\n        b.nodeMap = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.shapeRoot = void 0;\n        b.startAndEndRadians = void 0;\n        b.tree = void 0;\n        return b;\n      }\n\n      p(c, a);\n\n      c.prototype.alignDataLabel = function (b, c, d) {\n        if (!d.textPath || !d.textPath.enabled) return a.prototype.alignDataLabel.apply(this, arguments);\n      };\n\n      c.prototype.animate = function (a) {\n        var b = this.chart,\n            c = [b.plotWidth / 2, b.plotHeight / 2],\n            d = b.plotLeft,\n            f = b.plotTop;\n        b = this.group;\n        a ? (a = {\n          translateX: c[0] + d,\n          translateY: c[1] + f,\n          scaleX: .001,\n          scaleY: .001,\n          rotation: 10,\n          opacity: .01\n        }, b.attr(a)) : (a = {\n          translateX: d,\n          translateY: f,\n          scaleX: 1,\n          scaleY: 1,\n          rotation: 0,\n          opacity: 1\n        }, b.animate(a, this.options.animation));\n      };\n\n      c.prototype.drawPoints = function () {\n        var a = this,\n            b = a.mapOptionsToLevel,\n            c = a.shapeRoot,\n            d = a.group,\n            g = a.hasRendered,\n            h = a.rootNode,\n            e = a.idPreviousRoot,\n            m = a.nodeMap,\n            l = m[e],\n            n = l && l.shapeArgs;\n        l = a.points;\n        var p = a.startAndEndRadians,\n            q = a.chart,\n            k = q && q.options && q.options.chart || {},\n            r = \"boolean\" === typeof k.animation ? k.animation : !0,\n            u = a.center[3] / 2,\n            z = a.chart.renderer,\n            w = !1,\n            x = !1;\n\n        if (k = !!(r && g && h !== e && a.dataLabelsGroup)) {\n          a.dataLabelsGroup.attr({\n            opacity: 0\n          });\n\n          var B = function B() {\n            w = !0;\n            a.dataLabelsGroup && a.dataLabelsGroup.animate({\n              opacity: 1,\n              visibility: \"visible\"\n            });\n          };\n        }\n\n        l.forEach(function (f) {\n          var l = f.node,\n              k = b[l.level];\n          var t = f.shapeExisting || {};\n          var v = l.shapeArgs || {},\n              A = !(!l.visible || !l.shapeArgs);\n\n          if (g && r) {\n            var C = {};\n            var M = {\n              end: v.end,\n              start: v.start,\n              innerR: v.innerR,\n              r: v.r,\n              x: v.x,\n              y: v.y\n            };\n            A ? !f.graphic && n && (C = h === f.id ? {\n              start: p.start,\n              end: p.end\n            } : n.end <= v.start ? {\n              start: p.end,\n              end: p.end\n            } : {\n              start: p.start,\n              end: p.start\n            }, C.innerR = C.r = u) : f.graphic && (e === f.id ? M = {\n              innerR: u,\n              r: u\n            } : c && (M = c.end <= t.start ? {\n              innerR: u,\n              r: u,\n              start: p.end,\n              end: p.end\n            } : {\n              innerR: u,\n              r: u,\n              start: p.start,\n              end: p.start\n            }));\n            t = C;\n          } else M = v, t = {};\n\n          C = [v.plotX, v.plotY];\n          if (!f.node.isLeaf) if (h === f.id) {\n            var y = m[h];\n            y = y.parent;\n          } else y = f.id;\n          K(f, {\n            shapeExisting: v,\n            tooltipPos: C,\n            drillId: y,\n            name: \"\" + (f.name || f.id || f.index),\n            plotX: v.plotX,\n            plotY: v.plotY,\n            value: l.val,\n            isInside: A,\n            isNull: !A\n          });\n          y = f.options;\n          l = D(v) ? v : {};\n          y = D(y) ? y.dataLabels : {};\n          k = J(D(k) ? k.dataLabels : {})[0];\n          k = G({\n            style: {}\n          }, k, y);\n          y = k.rotationMode;\n\n          if (!I(k.rotation)) {\n            if (\"auto\" === y || \"circular\" === y) if (1 > f.innerArcLength && f.outerArcLength > l.radius) {\n              var w = 0;\n              f.dataLabelPath && \"circular\" === y && (k.textPath = {\n                enabled: !0\n              });\n            } else 1 < f.innerArcLength && f.outerArcLength > 1.5 * l.radius ? \"circular\" === y ? k.textPath = {\n              enabled: !0,\n              attributes: {\n                dy: 5\n              }\n            } : y = \"parallel\" : (f.dataLabel && f.dataLabel.textPathWrapper && \"circular\" === y && (k.textPath = {\n              enabled: !1\n            }), y = \"perpendicular\");\n            \"auto\" !== y && \"circular\" !== y && (w = l.end - (l.end - l.start) / 2);\n            k.style.width = \"parallel\" === y ? Math.min(2.5 * l.radius, (f.outerArcLength + f.innerArcLength) / 2) : l.radius;\n            \"perpendicular\" === y && f.series.chart.renderer.fontMetrics(k.style.fontSize).h > f.outerArcLength && (k.style.width = 1);\n            k.style.width = Math.max(k.style.width - 2 * (k.padding || 0), 1);\n            w = w * O % 180;\n            \"parallel\" === y && (w -= 90);\n            90 < w ? w -= 180 : -90 > w && (w += 180);\n            k.rotation = w;\n          }\n\n          k.textPath && (0 === f.shapeExisting.innerR && k.textPath.enabled ? (k.rotation = 0, k.textPath.enabled = !1, k.style.width = Math.max(2 * f.shapeExisting.r - 2 * (k.padding || 0), 1)) : f.dlOptions && f.dlOptions.textPath && !f.dlOptions.textPath.enabled && \"circular\" === y && (k.textPath.enabled = !0), k.textPath.enabled && (k.rotation = 0, k.style.width = Math.max((f.outerArcLength + f.innerArcLength) / 2 - 2 * (k.padding || 0), 1)));\n          0 === k.rotation && (k.rotation = .001);\n          f.dlOptions = k;\n\n          if (!x && A) {\n            x = !0;\n            var E = B;\n          }\n\n          f.draw({\n            animatableAttribs: M,\n            attribs: K(t, !q.styledMode && a.pointAttribs(f, f.selected && \"select\")),\n            onComplete: E,\n            group: d,\n            renderer: z,\n            shapeType: \"arc\",\n            shapeArgs: v\n          });\n        });\n        k && x ? (a.hasRendered = !1, a.options.dataLabels.defer = !0, t.prototype.drawDataLabels.call(a), a.hasRendered = !0, w && B()) : t.prototype.drawDataLabels.call(a);\n      };\n\n      c.prototype.layoutAlgorithm = function (a, b, c) {\n        var f = a.start,\n            d = a.end - f,\n            g = a.val,\n            e = a.x,\n            h = a.y,\n            l = c && D(c.levelSize) && I(c.levelSize.value) ? c.levelSize.value : 0,\n            k = a.r,\n            n = k + l,\n            p = c && I(c.slicedOffset) ? c.slicedOffset : 0;\n        return (b || []).reduce(function (a, b) {\n          var c = 1 / g * b.val * d,\n              m = f + c / 2,\n              q = e + Math.cos(m) * p;\n          m = h + Math.sin(m) * p;\n          b = {\n            x: b.sliced ? q : e,\n            y: b.sliced ? m : h,\n            innerR: k,\n            r: n,\n            radius: l,\n            start: f,\n            end: f + c\n          };\n          a.push(b);\n          f = b.end;\n          return a;\n        }, []);\n      };\n\n      c.prototype.setShapeArgs = function (a, b, c) {\n        var d = [],\n            f = c[a.level + 1];\n        a = a.children.filter(function (a) {\n          return a.visible;\n        });\n        d = this.layoutAlgorithm(b, a, f);\n        a.forEach(function (a, b) {\n          b = d[b];\n          var f = b.start + (b.end - b.start) / 2,\n              e = b.innerR + (b.r - b.innerR) / 2,\n              g = b.end - b.start;\n          e = 0 === b.innerR && 6.28 < g ? {\n            x: b.x,\n            y: b.y\n          } : {\n            x: b.x + Math.cos(f) * e,\n            y: b.y + Math.sin(f) * e\n          };\n          var h = a.val ? a.childrenTotal > a.val ? a.childrenTotal : a.val : a.childrenTotal;\n          this.points[a.i] && (this.points[a.i].innerArcLength = g * b.innerR, this.points[a.i].outerArcLength = g * b.r);\n          a.shapeArgs = G(b, {\n            plotX: e.x,\n            plotY: e.y + 4 * Math.abs(Math.cos(f))\n          });\n          a.values = G(b, {\n            val: h\n          });\n          a.children.length && this.setShapeArgs(a, a.values, c);\n        }, this);\n      };\n\n      c.prototype.translate = function () {\n        var a = this,\n            c = a.options,\n            g = a.center = b.call(a),\n            h = a.startAndEndRadians = d(c.startAngle, c.endAngle),\n            k = g[3] / 2,\n            p = g[2] / 2 - k,\n            e = w(a),\n            m = a.nodeMap,\n            l = m && m[e],\n            r = {};\n        a.shapeRoot = l && l.shapeArgs;\n        t.prototype.translate.call(a);\n        var u = a.tree = a.getTree();\n        a.renderTraverseUpButton(e);\n        m = a.nodeMap;\n        l = m[e];\n        var z = F(l.parent) ? l.parent : \"\";\n        z = m[z];\n        var x = q.getLevelFromAndTo(l);\n        var B = x.from,\n            D = x.to;\n        x = S({\n          from: B,\n          levels: a.options.levels,\n          to: D,\n          defaults: {\n            colorByPoint: c.colorByPoint,\n            dataLabels: c.dataLabels,\n            levelIsConstant: c.levelIsConstant,\n            levelSize: c.levelSize,\n            slicedOffset: c.slicedOffset\n          }\n        });\n        x = q.calculateLevelSizes(x, {\n          diffRadius: p,\n          from: B,\n          to: D\n        });\n        L(u, {\n          before: n,\n          idRoot: e,\n          levelIsConstant: c.levelIsConstant,\n          mapOptionsToLevel: x,\n          mapIdToNode: m,\n          points: a.points,\n          series: a\n        });\n        c = m[\"\"].shapeArgs = {\n          end: h.end,\n          r: k,\n          start: h.start,\n          val: l.val,\n          x: g[0],\n          y: g[1]\n        };\n        this.setShapeArgs(z, c, x);\n        a.mapOptionsToLevel = x;\n        a.data.forEach(function (b) {\n          r[b.id] && N(31, !1, a.chart);\n          r[b.id] = !0;\n        });\n        r = {};\n      };\n\n      c.defaultOptions = G(z.defaultOptions, {\n        center: [\"50%\", \"50%\"],\n        colorByPoint: !1,\n        opacity: 1,\n        dataLabels: {\n          allowOverlap: !0,\n          defer: !0,\n          rotationMode: \"auto\",\n          style: {\n            textOverflow: \"ellipsis\"\n          }\n        },\n        rootId: void 0,\n        levelIsConstant: !0,\n        levelSize: {\n          value: 1,\n          unit: \"weight\"\n        },\n        slicedOffset: 10\n      });\n      return c;\n    }(z);\n\n    K(k.prototype, {\n      drawDataLabels: a,\n      pointAttribs: h.prototype.pointAttribs,\n      pointClass: r,\n      utils: q\n    });\n    g.registerSeriesType(\"sunburst\", k);\n    \"\";\n    return k;\n  });\n  u(a, \"masters/modules/sunburst.src.js\", [], function () {});\n});","map":null,"metadata":{},"sourceType":"script"}