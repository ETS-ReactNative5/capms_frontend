{"ast":null,"code":"'use strict';\n/**\n * Set the title.\n */\n\nprocess.title = 'node-pre-gyp';\n\nvar node_pre_gyp = require('../');\n\nvar log = require('npmlog');\n/**\n * Process and execute the selected commands.\n */\n\n\nvar prog = new node_pre_gyp.Run({\n  argv: process.argv\n});\nvar completed = false;\n\nif (prog.todo.length === 0) {\n  if (~process.argv.indexOf('-v') || ~process.argv.indexOf('--version')) {\n    console.log('v%s', prog.version);\n    process.exit(0);\n  } else if (~process.argv.indexOf('-h') || ~process.argv.indexOf('--help')) {\n    console.log('%s', prog.usage());\n    process.exit(0);\n  }\n\n  console.log('%s', prog.usage());\n  process.exit(1);\n} // if --no-color is passed\n\n\nif (prog.opts && Object.hasOwnProperty.call(prog, 'color') && !prog.opts.color) {\n  log.disableColor();\n}\n\nlog.info('it worked if it ends with', 'ok');\nlog.verbose('cli', process.argv);\nlog.info('using', process.title + '@%s', prog.version);\nlog.info('using', 'node@%s | %s | %s', process.versions.node, process.platform, process.arch);\n/**\n * Change dir if -C/--directory was passed.\n */\n\nvar dir = prog.opts.directory;\n\nif (dir) {\n  var fs = require('fs');\n\n  try {\n    var stat = fs.statSync(dir);\n\n    if (stat.isDirectory()) {\n      log.info('chdir', dir);\n      process.chdir(dir);\n    } else {\n      log.warn('chdir', dir + ' is not a directory');\n    }\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      log.warn('chdir', dir + ' is not a directory');\n    } else {\n      log.warn('chdir', 'error during chdir() \"%s\"', e.message);\n    }\n  }\n}\n\nfunction run() {\n  var command = prog.todo.shift();\n\n  if (!command) {\n    // done!\n    completed = true;\n    log.info('ok');\n    return;\n  } // set binary.host when appropriate. host determines the s3 target bucket.\n\n\n  var target = prog.setBinaryHostProperty(command.name);\n\n  if (target && ['install', 'publish', 'unpublish', 'info'].indexOf(command.name) >= 0) {\n    log.info('using binary.host: ' + prog.package_json.binary.host);\n  }\n\n  prog.commands[command.name](command.args, function (err) {\n    if (err) {\n      log.error(command.name + ' error');\n      log.error('stack', err.stack);\n      errorMessage();\n      log.error('not ok');\n      console.log(err.message);\n      return process.exit(1);\n    }\n\n    var args_array = [].slice.call(arguments, 1);\n\n    if (args_array.length) {\n      console.log.apply(console, args_array);\n    } // now run the next command in the queue\n\n\n    process.nextTick(run);\n  });\n}\n\nprocess.on('exit', function (code) {\n  if (!completed && !code) {\n    log.error('Completion callback never invoked!');\n    errorMessage();\n    process.exit(6);\n  }\n});\nprocess.on('uncaughtException', function (err) {\n  log.error('UNCAUGHT EXCEPTION');\n  log.error('stack', err.stack);\n  errorMessage();\n  process.exit(7);\n});\n\nfunction errorMessage() {\n  // copied from npm's lib/util/error-handler.js\n  var os = require('os');\n\n  log.error('System', os.type() + ' ' + os.release());\n  log.error('command', process.argv.map(JSON.stringify).join(' '));\n  log.error('cwd', process.cwd());\n  log.error('node -v', process.version);\n  log.error(process.title + ' -v', 'v' + prog.package.version);\n} // start running the given commands!\n\n\nrun();","map":null,"metadata":{},"sourceType":"script"}