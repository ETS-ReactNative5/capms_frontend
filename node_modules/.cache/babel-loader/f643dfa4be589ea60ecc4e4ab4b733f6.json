{"ast":null,"code":"'use strict';\n/**\n * Module exports.\n */\n\nmodule.exports = exports;\n/**\n * Module dependencies.\n */\n// load mocking control function for accessing s3 via https. the function is a noop always returning\n// false if not mocking.\n\nexports.mockS3Http = require('./util/s3_setup').get_mockS3Http();\nexports.mockS3Http('on');\nvar mocking = exports.mockS3Http('get');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar nopt = require('nopt');\n\nvar log = require('npmlog');\n\nlog.disableProgress();\n\nvar napi = require('./util/napi.js');\n\nvar EE = require('events').EventEmitter;\n\nvar inherits = require('util').inherits;\n\nvar cli_commands = ['clean', 'install', 'reinstall', 'build', 'rebuild', 'package', 'testpackage', 'publish', 'unpublish', 'info', 'testbinary', 'reveal', 'configure'];\nvar aliases = {}; // differentiate node-pre-gyp's logs from npm's\n\nlog.heading = 'node-pre-gyp';\n\nif (mocking) {\n  log.warn(\"mocking s3 to \".concat(process.env.node_pre_gyp_mock_s3));\n} // this is a getter to avoid circular reference warnings with node v14.\n\n\nObject.defineProperty(exports, 'find', {\n  get: function get() {\n    return require('./pre-binding').find;\n  },\n  enumerable: true\n}); // in the following, \"my_module\" is using node-pre-gyp to\n// prebuild and install pre-built binaries. \"main_module\"\n// is using \"my_module\".\n//\n// \"bin/node-pre-gyp\" invokes Run() without a path. the\n// expectation is that the working directory is the package\n// root \"my_module\". this is true because in all cases npm is\n// executing a script in the context of \"my_module\".\n//\n// \"pre-binding.find()\" is executed by \"my_module\" but in the\n// context of \"main_module\". this is because \"main_module\" is\n// executing and requires \"my_module\" which is then executing\n// \"pre-binding.find()\" via \"node-pre-gyp.find()\", so the working\n// directory is that of \"main_module\".\n//\n// that's why \"find()\" must pass the path to package.json.\n//\n\nfunction Run(_ref) {\n  var _ref$package_json_pat = _ref.package_json_path,\n      package_json_path = _ref$package_json_pat === void 0 ? './package.json' : _ref$package_json_pat,\n      argv = _ref.argv;\n  this.package_json_path = package_json_path;\n  this.commands = {};\n  var self = this;\n  cli_commands.forEach(function (command) {\n    self.commands[command] = function (argvx, callback) {\n      log.verbose('command', command, argvx);\n      return require('./' + command)(self, argvx, callback);\n    };\n  });\n  this.parseArgv(argv); // this is set to true after the binary.host property was set to\n  // either staging_host or production_host.\n\n  this.binaryHostSet = false;\n}\n\ninherits(Run, EE);\nexports.Run = Run;\nvar proto = Run.prototype;\n/**\n * Export the contents of the package.json.\n */\n\nproto.package = require('../package.json');\n/**\n * nopt configuration definitions\n */\n\nproto.configDefs = {\n  help: Boolean,\n  // everywhere\n  arch: String,\n  // 'configure'\n  debug: Boolean,\n  // 'build'\n  directory: String,\n  // bin\n  proxy: String,\n  // 'install'\n  loglevel: String // everywhere\n\n};\n/**\n * nopt shorthands\n */\n\nproto.shorthands = {\n  release: '--no-debug',\n  C: '--directory',\n  debug: '--debug',\n  j: '--jobs',\n  silent: '--loglevel=silent',\n  silly: '--loglevel=silly',\n  verbose: '--loglevel=verbose'\n};\n/**\n * expose the command aliases for the bin file to use.\n */\n\nproto.aliases = aliases;\n/**\n * Parses the given argv array and sets the 'opts', 'argv',\n * 'command', and 'package_json' properties.\n */\n\nproto.parseArgv = function parseOpts(argv) {\n  var _this = this;\n\n  this.opts = nopt(this.configDefs, this.shorthands, argv);\n  this.argv = this.opts.argv.remain.slice();\n  var commands = this.todo = []; // create a copy of the argv array with aliases mapped\n\n  argv = this.argv.map(function (arg) {\n    // is this an alias?\n    if (arg in _this.aliases) {\n      arg = _this.aliases[arg];\n    }\n\n    return arg;\n  }); // process the mapped args into \"command\" objects (\"name\" and \"args\" props)\n\n  argv.slice().forEach(function (arg) {\n    if (arg in _this.commands) {\n      var args = argv.splice(0, argv.indexOf(arg));\n      argv.shift();\n\n      if (commands.length > 0) {\n        commands[commands.length - 1].args = args;\n      }\n\n      commands.push({\n        name: arg,\n        args: []\n      });\n    }\n  });\n\n  if (commands.length > 0) {\n    commands[commands.length - 1].args = argv.splice(0);\n  } // if a directory was specified package.json is assumed to be relative\n  // to it.\n\n\n  var package_json_path = this.package_json_path;\n\n  if (this.opts.directory) {\n    package_json_path = path.join(this.opts.directory, package_json_path);\n  }\n\n  this.package_json = JSON.parse(fs.readFileSync(package_json_path)); // expand commands entries for multiple napi builds\n\n  this.todo = napi.expand_commands(this.package_json, this.opts, commands); // support for inheriting config env variables from npm\n\n  var npm_config_prefix = 'npm_config_';\n  Object.keys(process.env).forEach(function (name) {\n    if (name.indexOf(npm_config_prefix) !== 0) return;\n    var val = process.env[name];\n\n    if (name === npm_config_prefix + 'loglevel') {\n      log.level = val;\n    } else {\n      // add the user-defined options to the config\n      name = name.substring(npm_config_prefix.length); // avoid npm argv clobber already present args\n      // which avoids problem of 'npm test' calling\n      // script that runs unique npm install commands\n\n      if (name === 'argv') {\n        if (_this.opts.argv && _this.opts.argv.remain && _this.opts.argv.remain.length) {// do nothing\n        } else {\n          _this.opts[name] = val;\n        }\n      } else {\n        _this.opts[name] = val;\n      }\n    }\n  });\n\n  if (this.opts.loglevel) {\n    log.level = this.opts.loglevel;\n  }\n\n  log.resume();\n};\n/**\n * allow the binary.host property to be set at execution time.\n *\n * for this to take effect requires all the following to be true.\n * - binary is a property in package.json\n * - binary.host is falsey\n * - binary.staging_host is not empty\n * - binary.production_host is not empty\n *\n * if any of the previous checks fail then the function returns an empty string\n * and makes no changes to package.json's binary property.\n *\n *\n * if command is \"publish\" then the default is set to \"binary.staging_host\"\n * if command is not \"publish\" the the default is set to \"binary.production_host\"\n *\n * if the command-line option '--s3_host' is set to \"staging\" or \"production\" then\n * \"binary.host\" is set to the specified \"staging_host\" or \"production_host\". if\n * '--s3_host' is any other value an exception is thrown.\n *\n * if '--s3_host' is not present then \"binary.host\" is set to the default as above.\n *\n * this strategy was chosen so that any command other than \"publish\" or \"unpublish\" uses \"production\"\n * as the default without requiring any command-line options but that \"publish\" and \"unpublish\" require\n * '--s3_host production_host' to be specified in order to *really* publish (or unpublish). publishing\n * to staging can be done freely without worrying about disturbing any production releases.\n */\n\n\nproto.setBinaryHostProperty = function (command) {\n  if (this.binaryHostSet) {\n    return this.package_json.binary.host;\n  }\n\n  var p = this.package_json; // don't set anything if host is present. it must be left blank to trigger this.\n\n  if (!p || !p.binary || p.binary.host) {\n    return '';\n  } // and both staging and production must be present. errors will be reported later.\n\n\n  if (!p.binary.staging_host || !p.binary.production_host) {\n    return '';\n  }\n\n  var target = 'production_host';\n\n  if (command === 'publish' || command === 'unpublish') {\n    target = 'staging_host';\n  } // the environment variable has priority over the default or the command line. if\n  // either the env var or the command line option are invalid throw an error.\n\n\n  var npg_s3_host = process.env.node_pre_gyp_s3_host;\n\n  if (npg_s3_host === 'staging' || npg_s3_host === 'production') {\n    target = \"\".concat(npg_s3_host, \"_host\");\n  } else if (this.opts['s3_host'] === 'staging' || this.opts['s3_host'] === 'production') {\n    target = \"\".concat(this.opts['s3_host'], \"_host\");\n  } else if (this.opts['s3_host'] || npg_s3_host) {\n    throw new Error(\"invalid s3_host \".concat(this.opts['s3_host'] || npg_s3_host));\n  }\n\n  p.binary.host = p.binary[target];\n  this.binaryHostSet = true;\n  return p.binary.host;\n};\n/**\n * Returns the usage instructions for node-pre-gyp.\n */\n\n\nproto.usage = function usage() {\n  var str = ['', '  Usage: node-pre-gyp <command> [options]', '', '  where <command> is one of:', cli_commands.map(function (c) {\n    return '    - ' + c + ' - ' + require('./' + c).usage;\n  }).join('\\n'), '', 'node-pre-gyp@' + this.version + '  ' + path.resolve(__dirname, '..'), 'node@' + process.versions.node].join('\\n');\n  return str;\n};\n/**\n * Version number getter.\n */\n\n\nObject.defineProperty(proto, 'version', {\n  get: function get() {\n    return this.package.version;\n  },\n  enumerable: true\n});","map":null,"metadata":{},"sourceType":"script"}