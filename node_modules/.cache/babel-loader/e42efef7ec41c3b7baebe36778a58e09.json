{"ast":null,"code":"'use strict';\n\nmodule.exports = exports;\n\nvar url = require('url');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nmodule.exports.detect = function (opts, config) {\n  var to = opts.hosted_path;\n  var uri = url.parse(to);\n  config.prefix = !uri.pathname || uri.pathname === '/' ? '' : uri.pathname.replace('/', '');\n\n  if (opts.bucket && opts.region) {\n    config.bucket = opts.bucket;\n    config.region = opts.region;\n    config.endpoint = opts.host;\n    config.s3ForcePathStyle = opts.s3ForcePathStyle;\n  } else {\n    var parts = uri.hostname.split('.s3');\n    var bucket = parts[0];\n\n    if (!bucket) {\n      return;\n    }\n\n    if (!config.bucket) {\n      config.bucket = bucket;\n    }\n\n    if (!config.region) {\n      var region = parts[1].slice(1).split('.')[0];\n\n      if (region === 'amazonaws') {\n        config.region = 'us-east-1';\n      } else {\n        config.region = region;\n      }\n    }\n  }\n};\n\nmodule.exports.get_s3 = function (config) {\n  if (process.env.node_pre_gyp_mock_s3) {\n    // here we're mocking. node_pre_gyp_mock_s3 is the scratch directory\n    // for the mock code.\n    var AWSMock = require('mock-aws-s3');\n\n    var os = require('os');\n\n    AWSMock.config.basePath = \"\".concat(os.tmpdir(), \"/mock\");\n\n    var _s = AWSMock.S3(); // wrapped callback maker. fs calls return code of ENOENT but AWS.S3 returns\n    // NotFound.\n\n\n    var wcb = function wcb(fn) {\n      return function (err) {\n        if (err && err.code === 'ENOENT') {\n          err.code = 'NotFound';\n        }\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return fn.apply(void 0, [err].concat(args));\n      };\n    };\n\n    return {\n      listObjects: function listObjects(params, callback) {\n        return _s.listObjects(params, wcb(callback));\n      },\n      headObject: function headObject(params, callback) {\n        return _s.headObject(params, wcb(callback));\n      },\n      deleteObject: function deleteObject(params, callback) {\n        return _s.deleteObject(params, wcb(callback));\n      },\n      putObject: function putObject(params, callback) {\n        return _s.putObject(params, wcb(callback));\n      }\n    };\n  } // if not mocking then setup real s3.\n\n\n  var AWS = require('aws-sdk');\n\n  AWS.config.update(config);\n  var s3 = new AWS.S3(); // need to change if additional options need to be specified.\n\n  return {\n    listObjects: function listObjects(params, callback) {\n      return s3.listObjects(params, callback);\n    },\n    headObject: function headObject(params, callback) {\n      return s3.headObject(params, callback);\n    },\n    deleteObject: function deleteObject(params, callback) {\n      return s3.deleteObject(params, callback);\n    },\n    putObject: function putObject(params, callback) {\n      return s3.putObject(params, callback);\n    }\n  };\n}; //\n// function to get the mocking control function. if not mocking it returns a no-op.\n//\n// if mocking it sets up the mock http interceptors that use the mocked s3 file system\n// to fulfill reponses.\n\n\nmodule.exports.get_mockS3Http = function () {\n  var mock_s3 = false;\n\n  if (!process.env.node_pre_gyp_mock_s3) {\n    return function () {\n      return mock_s3;\n    };\n  }\n\n  var nock = require('nock'); // the bucket used for testing, as addressed by https.\n\n\n  var host = 'https://mapbox-node-pre-gyp-public-testing-bucket.s3.us-east-1.amazonaws.com';\n  var mockDir = process.env.node_pre_gyp_mock_s3 + '/mapbox-node-pre-gyp-public-testing-bucket'; // function to setup interceptors. they are \"turned off\" by setting mock_s3 to false.\n\n  var mock_http = function mock_http() {\n    // eslint-disable-next-line no-unused-vars\n    function get(uri, requestBody) {\n      var filepath = path.join(mockDir, uri.replace('%2B', '+'));\n\n      try {\n        fs.accessSync(filepath, fs.constants.R_OK);\n      } catch (e) {\n        return [404, 'not found\\n'];\n      } // the mock s3 functions just write to disk, so just read from it.\n\n\n      return [200, fs.createReadStream(filepath)];\n    } // eslint-disable-next-line no-unused-vars\n\n\n    return nock(host).persist().get(function () {\n      return mock_s3;\n    }) // mock any uri for s3 when true\n    .reply(get);\n  }; // setup interceptors. they check the mock_s3 flag to determine whether to intercept.\n\n\n  mock_http(nock, host, mockDir); // function to turn matching all requests to s3 on/off.\n\n  var mockS3Http = function mockS3Http(action) {\n    var previous = mock_s3;\n\n    if (action === 'off') {\n      mock_s3 = false;\n    } else if (action === 'on') {\n      mock_s3 = true;\n    } else if (action !== 'get') {\n      throw new Error(\"illegal action for setMockHttp \".concat(action));\n    }\n\n    return previous;\n  }; // call mockS3Http with the argument\n  // - 'on' - turn it on\n  // - 'off' - turn it off (used by fetch.test.js so it doesn't interfere with redirects)\n  // - 'get' - return true or false for 'on' or 'off'\n\n\n  return mockS3Http;\n};","map":null,"metadata":{},"sourceType":"script"}